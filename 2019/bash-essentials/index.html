<!DOCTYPE html>
<html lang=EN>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-62489908-6"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-62489908-6');
    </script>

    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="When starting out with the bash shell, there are a few essential concepts beyond the basic commands that one must be aware of.  Beyond the basics and user permissions, one must learn about environment">
<meta name="keywords" content="linux">
<meta property="og:type" content="article">
<meta property="og:title" content="Bash Essentials">
<meta property="og:url" content="http://zachgoll.github.io/blog/2019/bash-essentials/index.html">
<meta property="og:site_name" content="Zach Gollwitzer">
<meta property="og:description" content="When starting out with the bash shell, there are a few essential concepts beyond the basic commands that one must be aware of.  Beyond the basics and user permissions, one must learn about environment">
<meta property="og:locale" content="EN">
<meta property="og:image" content="http://zachgoll.github.io/blog/2019/bash-essentials/vscode-search.png">
<meta property="og:image" content="http://zachgoll.github.io/blog/2019/bash-essentials/digital-ocean-key.png">
<meta property="og:image" content="http://zachgoll.github.io/blog/2019/bash-essentials/basic-web-search.jpg">
<meta property="og:image" content="http://zachgoll.github.io/blog/2019/bash-essentials/ipaddresses.PNG">
<meta property="og:image" content="http://zachgoll.github.io/blog/2019/bash-essentials/processes-linux.png">
<meta property="og:image" content="http://zachgoll.github.io/blog/2019/bash-essentials/top-header.png">
<meta property="og:updated_time" content="2019-11-25T15:55:49.362Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bash Essentials">
<meta name="twitter:description" content="When starting out with the bash shell, there are a few essential concepts beyond the basic commands that one must be aware of.  Beyond the basics and user permissions, one must learn about environment">
<meta name="twitter:image" content="http://zachgoll.github.io/blog/2019/bash-essentials/vscode-search.png">
    
    
        
          
              <link rel="shortcut icon" href="/blog/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/blog/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Bash Essentials</title>
    <!-- styles -->
    <link rel="stylesheet" href="/blog/css/style.css">
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="http://zachgoll.github.io">Home</a></li>
         
          <li><a href="/blog/archives/">Writing</a></li>
         
          <li><a href="http://zachgoll.github.io/portfolio">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/blog/2019/ip-addresses-netmasks/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/blog/2019/user-permissions/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://zachgoll.github.io/blog/2019/bash-essentials/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://zachgoll.github.io/blog/2019/bash-essentials/&text=Bash Essentials"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://zachgoll.github.io/blog/2019/bash-essentials/&title=Bash Essentials"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://zachgoll.github.io/blog/2019/bash-essentials/&is_video=false&description=Bash Essentials"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Bash Essentials&body=Check out this article: http://zachgoll.github.io/blog/2019/bash-essentials/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://zachgoll.github.io/blog/2019/bash-essentials/&title=Bash Essentials"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://zachgoll.github.io/blog/2019/bash-essentials/&title=Bash Essentials"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://zachgoll.github.io/blog/2019/bash-essentials/&title=Bash Essentials"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://zachgoll.github.io/blog/2019/bash-essentials/&title=Bash Essentials"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://zachgoll.github.io/blog/2019/bash-essentials/&name=Bash Essentials&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Environment-variables"><span class="toc-number">1.</span> <span class="toc-text">Environment variables</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Shell-Variables"><span class="toc-number">1.1.</span> <span class="toc-text">Shell Variables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PATH-variable"><span class="toc-number">1.2.</span> <span class="toc-text">PATH variable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Common-Commands"><span class="toc-number">1.3.</span> <span class="toc-text">Common Commands</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#grep"><span class="toc-number">1.3.1.</span> <span class="toc-text">grep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#awk-and-sed"><span class="toc-number">1.3.2.</span> <span class="toc-text">awk and sed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Less"><span class="toc-number">1.3.3.</span> <span class="toc-text">Less</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find-and-exec"><span class="toc-number">1.3.4.</span> <span class="toc-text">find and exec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tar-gzip-gunzip"><span class="toc-number">1.3.5.</span> <span class="toc-text">tar, gzip, gunzip</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Advanced-Bash"><span class="toc-number">2.</span> <span class="toc-text">Advanced Bash</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Regular-Expressions"><span class="toc-number">2.1.</span> <span class="toc-text">Regular Expressions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Detailed-Example-Regular-Expression"><span class="toc-number">2.1.1.</span> <span class="toc-text">Detailed Example Regular Expression</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bash-Scripting"><span class="toc-number">2.2.</span> <span class="toc-text">Bash Scripting</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Variable-declarations"><span class="toc-number">2.2.1.</span> <span class="toc-text">Variable declarations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Built-In-Variables"><span class="toc-number">2.2.2.</span> <span class="toc-text">Built-In Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Command-Line-Arguments"><span class="toc-number">2.2.3.</span> <span class="toc-text">Command Line Arguments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reading-user-input"><span class="toc-number">2.2.4.</span> <span class="toc-text">Reading user input</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-loops"><span class="toc-number">2.2.5.</span> <span class="toc-text">for loops</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-then-statements"><span class="toc-number">2.2.6.</span> <span class="toc-text">if-then statements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Functions"><span class="toc-number">2.2.7.</span> <span class="toc-text">Functions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Virtual-Machines-and-SSH-Protocol"><span class="toc-number">2.3.</span> <span class="toc-text">Virtual Machines and SSH Protocol</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Permanently-Add-Keys-to-ssh-agent"><span class="toc-number">2.3.1.</span> <span class="toc-text">Permanently Add Keys to ssh-agent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#From-local-computer-to-remote-machine"><span class="toc-number">2.3.2.</span> <span class="toc-text">From local computer to remote machine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#From-remote-machine-to-local-computer"><span class="toc-number">2.3.3.</span> <span class="toc-text">From remote machine to local computer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Downloading-packages-to-your-remote-machine-with-wget"><span class="toc-number">2.3.4.</span> <span class="toc-text">Downloading packages to your remote machine with wget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-VSCode-with-your-remote-machine"><span class="toc-number">2.3.5.</span> <span class="toc-text">Using VSCode with your remote machine</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Networking-on-Command-Line"><span class="toc-number">2.4.</span> <span class="toc-text">Networking on Command Line</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Your-home-network-and-the-internet"><span class="toc-number">2.4.1.</span> <span class="toc-text">Your home network and the internet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ifconfig"><span class="toc-number">2.4.2.</span> <span class="toc-text">ifconfig</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ping"><span class="toc-number">2.4.3.</span> <span class="toc-text">ping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#traceroute"><span class="toc-number">2.4.4.</span> <span class="toc-text">traceroute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netstat"><span class="toc-number">2.4.5.</span> <span class="toc-text">netstat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dig-host-whois"><span class="toc-number">2.4.6.</span> <span class="toc-text">dig/host/whois</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Process-Management-and-System-Management"><span class="toc-number">2.5.</span> <span class="toc-text">Process Management and System Management</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What-is-a-Process"><span class="toc-number">2.5.1.</span> <span class="toc-text">What is a Process?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Processes-Behind-the-Scenes"><span class="toc-number">2.5.2.</span> <span class="toc-text">Processes Behind the Scenes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Foreground-vs-Background-Processes"><span class="toc-number">2.5.3.</span> <span class="toc-text">Foreground vs. Background Processes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ps-and-top-commands-system-performance-management"><span class="toc-number">2.5.4.</span> <span class="toc-text">ps and top commands (system performance management)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lsof"><span class="toc-number">2.5.5.</span> <span class="toc-text">lsof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free-time"><span class="toc-number">2.5.6.</span> <span class="toc-text">free, time</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">2.6.</span> <span class="toc-text">Conclusion</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Bash Essentials
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Zach Gollwitzer</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-02-03T21:50:19.000Z" itemprop="datePublished">2019-02-03</time>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/blog/tags/linux/">linux</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>When starting out with the bash shell, there are a few essential concepts beyond the basic commands that one must be aware of.  Beyond <a href>the basics</a> and <a href="/blog/2019/user-permissions/">user permissions</a>, one must learn about environment variables, aliases, and some more advanced commands relating to topics of networking, process management, ssh, and scripting.</p>
<h1 id="Environment-variables"><a href="#Environment-variables" class="headerlink" title="Environment variables"></a>Environment variables</h1><iframe width="560" height="315" src="https://www.youtube.com/embed/5e-kS5LkByc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>An environment variable can come in two sizes–global or local.  A global environment variable is one that is set upon initialization of a shell and can be used across all your shells.  A local environment variable is one that is set during a shell session and is erased when the shell is closed.  To create a local environment variable, just export it in your shell.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> MY_VARIABLE=<span class="string">"some value"</span></span><br></pre></td></tr></table></figure>
<p>You can use this as long as the shell is still open.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$MY_VARIABLE</span> <span class="comment"># some value</span></span><br></pre></td></tr></table></figure>
<p>As soon as you close the shell, this will no longer be a variable.  If you want to create a global variable, you will need to export it in one of your bash configuration files.  It is recommended that you place it in the <code>~/.profile</code> file as described in <a href="/blog/2019/user-permissions/">this tutorial</a>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.profile</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GLOBAL_VARIABLE=<span class="string">"some value"</span></span><br></pre></td></tr></table></figure>
<p>To see all of the environment variables in your current environment (both local and global), you can type the following command.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env</span><br></pre></td></tr></table></figure>
<h2 id="Shell-Variables"><a href="#Shell-Variables" class="headerlink" title="Shell Variables"></a>Shell Variables</h2><p>Oftentimes, users will get confused when talking about <em>environment</em> variables and <em>shell</em> variables.  Regardless of whether the environment variable is local or global, all the scripts running in that shell session will have access to the variable.  With a shell variable, other scripts will not have access to it.  The following is how we declare a shell variable.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MY_SHELL_VARIABLE=<span class="string">"some value"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$MY_SHELL_VARIABLE</span>  <span class="comment"># some value</span></span><br></pre></td></tr></table></figure>
<p>This variable will not be available to any script until we export it and make it an environment variable.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> MY_SHELL_VARIABLE</span><br></pre></td></tr></table></figure>
<h2 id="PATH-variable"><a href="#PATH-variable" class="headerlink" title="PATH variable"></a>PATH variable</h2><p>The most important global environment variable that you must set is the <code>PATH</code> variable.  This is the variable that tells the bash shell where to find different executable files and scripts.  The shell will check the directories listed in the <code>PATH</code> variable for the script you are trying to find.  Here is an example path.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/bin:/usr/bin:/bin</span><br></pre></td></tr></table></figure>
<p>With this example path, when you try to run a script in the terminal such as <code>cat</code>, bash will first look in the <code>/usr/local/bin</code> for this command.  If it doesn’t find it there, it will look in <code>/usr/bin</code>, and finally, <code>/bin</code>.  If you need to modify the path, you can update it in your <code>~/.profile</code> like so: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/home/zach/script-location:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p>This will add the <code>/home/zach/script-location</code> directory to the beginning of the <code>PATH</code> variable.  If you want to add it at the end, you can change the line to this: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/zach/script</span><br></pre></td></tr></table></figure>
<p>With this new knowledge, we can create our own scripts and add those scripts to our path so we can run them automatically.  Let’s create a directory in our home folder that will hold all our custom scripts.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~ </span><br><span class="line">mkdir bin </span><br><span class="line">touch bin/my-simple-script</span><br></pre></td></tr></table></figure>
<p>Add the following to <code>my-simple-script</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"I am a useless script for tutorial purposes only"</span></span><br></pre></td></tr></table></figure>
<p>Now make the script executable.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 775 my-simple-script</span><br></pre></td></tr></table></figure>
<p>We need to add the new <code>bin/</code> directory to our path.  Open <code>~/.profile</code> (or wherever you define your <code>PATH</code> environment variable), and add the following line.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:~/bin</span><br></pre></td></tr></table></figure>
<p>Finally, you need to source <code>~/.profile</code> to activate this new change.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.profile</span><br></pre></td></tr></table></figure>
<p>You can now run your simple script from the command line by typing the name of it.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my-simple-script  </span><br><span class="line"><span class="comment"># I am a useless script for tutorial purposes only</span></span><br></pre></td></tr></table></figure>
<h2 id="Common-Commands"><a href="#Common-Commands" class="headerlink" title="Common Commands"></a>Common Commands</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/yCTnihfbPCo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>Aside from basic commands such as <code>cd</code>, <code>ls</code>, <code>mkdir</code>, <code>touch</code>, etc., there is a short list of commands that I think every bash user should know about and attempt to use on a regular basis.</p>
<ul>
<li>grep</li>
<li>awk/sed</li>
<li>less</li>
<li>find and exec</li>
<li>gunzip</li>
<li>tar</li>
</ul>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>Grep is a tool that will find certain patterns or words in one or more files.  It comes in two versions–BSD and GNU.  Mac computers will come with the BSD version while linux computers will come with the GNU version.  For our intent, these versions are identical, but if you ever run into issues cross-platform, be sure to check that the grep command you are executing is supported in your grep version (certain types of regular expressions not supported in BSD grep).</p>
<p>You can think of grep as the “search” tool built-in to the command line.  In today’s computing environments, there are plenty of search tools and in most cases, I would opt to use the search tools provided to me.  For example, in the Visual Studio Code Editor, I can use the search bar to search through all the files in my project for a specific word or even regular expression, and I will get results listing the files that the expression was found in, what line it was found on, etc.</p>
<img src="/blog/2019/bash-essentials/vscode-search.png">
<p>In this example, I was searching my entire blog for the word “grep” and found it in 3 separate files.  But what if VSCode is not availabe to you?  Maybe you are managing a remote machine and you simply cannot access this awesome search feature?  In that case, you are going to need to use grep.  The basic syntax for using grep is the following: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [all your options] <span class="string">"text to search for"</span> &lt;file-to-search-in&gt;</span><br></pre></td></tr></table></figure>
<p>For example, if I wanted to search the <code>/etc/passwd</code> file (where all the users on our system are stored) for my name, I could do it like so.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Must use sudo because this file is protected</span></span><br><span class="line"><span class="comment"># The -i flag will make my search case insensitive </span></span><br><span class="line">sudo grep -i <span class="string">"zach"</span> /etc/passwd </span><br><span class="line"></span><br><span class="line"><span class="comment"># zach:x:1000:1000:Zach,,,:/home/zach:/bin/bash</span></span><br></pre></td></tr></table></figure>
<p>Although this tutorial is not meant to cover regular expressions in detail, I could also search by a regular expression.  Maybe I wanted to match any user that had a name equaling 3 characters.  I would perform the following search while adding the <code>-E</code> flag for “extended regular expressions”.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo grep --color -E <span class="string">"^[a-z]&#123;3&#125;:"</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output --- </span></span><br><span class="line"><span class="comment">#bin:x:2:2:bin:/bin:/usr/sbin/nologin</span></span><br><span class="line"><span class="comment">#sys:x:3:3:sys:/dev:/usr/sbin/nologin</span></span><br><span class="line"><span class="comment">#man:x:6:12:man:/var/cache/man:/usr/sbin/nologin</span></span><br><span class="line"><span class="comment">#irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin</span></span><br><span class="line"><span class="comment">#gdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false</span></span><br></pre></td></tr></table></figure>
<p><code>bin</code>, <code>sys</code>, <code>man</code>, <code>irc</code>, and <code>gdm</code> are all three letter usernames.  If your output does not print in color, you can add the <code>--color</code> flag to your command.</p>
<p>Another way to use grep is through piping.  We can pip the stdout of one command to the stdin of grep.  The same command we just wrote about can be modified and written like so: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /etc/passwd | grep --color -E <span class="string">"^[a-z]&#123;3&#125;:"</span></span><br></pre></td></tr></table></figure>
<p>Again, the <code>grep</code> utility is useful for quick searches when you do not have access to your normal text editor like VSCode.</p>
<h3 id="awk-and-sed"><a href="#awk-and-sed" class="headerlink" title="awk and sed"></a>awk and sed</h3><p>Nowadays, <code>awk</code> and <code>sed</code> are contentious topics, and in this section, I hope to clarify <em>why</em> this is the case and introduce the two commands’ basic usages.  The reason these two commands are contested frequently is due to the better alternatives that we have today.  Both of these tools are considered text editors because they can find <em>and</em> replace parts of a file or files.  </p>
<p>Sed is a “stream editor” (looks at each line character by character) and is not considered a full programming language.  It is great for little find and replace operations across one or more files.  Again, I would recommend just using a built-in find/replace utility if it is available (like in VSCode), but sometimes this is not accessible.</p>
<p>Awk considered a computationally complete programming language and is catered more towards large data that is delimiter separated.  For example, the <code>awk</code> tool would be good at parsing through a csv file, or a file separated by spaces because it reads each line in chunks rather than characters.</p>
<p>The reason these utilities are highly contentious is because anything you can do in sed or awk can be done in Perl or Python in a simpler manner.  Perl and Python are far more advanced and usable scripting languages.  Many will argue the superior performance of sed and awk in certain situations, but for all practical purposes, it is more often the case that Perl or Python will be the better solution.</p>
<p>Not to beat a dead horse here, but again, if you do not have access to Python or Perl (remember, you must download these to a machine while sed/awk are usually installed already), you are going to need to learn how to use sed and awk.  Now the question becomes–what is the difference?  Why would I use sed over awk or vice-versa?  Here are few quick rules of thumb: </p>
<ul>
<li>For simple text transformations (like find/replace), use sed.</li>
<li>For simple formatting transformations, use awk</li>
<li>For complex formatting/text transformations, use awk</li>
</ul>
<p>Let’s take a look at an example of each and cover the basic usage of both tools.  We will start with a simple find/replace operation with sed.  For these examples, I will be using a sample file of Apple Inc. stock data over the last 3 months called <code>aapl.csv</code>.  Here is the data: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Date,Open,High,Low,Close,Adj Close,Volume</span><br><span class="line">2018-11-06,201.919998,204.720001,201.690002,203.770004,203.061493,31882900</span><br><span class="line">2018-11-07,205.970001,210.059998,204.130005,209.949997,209.219986,33424400</span><br><span class="line">2018-11-08,209.979996,210.119995,206.750000,208.490005,208.490005,25362600</span><br><span class="line"></span><br><span class="line">... omitted for brevity ...</span><br><span class="line"></span><br><span class="line">2019-02-04,167.410004,171.660004,167.279999,171.250000,171.250000,31495500</span><br><span class="line">2019-02-05,172.860001,175.080002,172.350006,174.179993,174.179993,36066500</span><br></pre></td></tr></table></figure>
<p>Say I wanted to replace all the commas with spaces instead.  I could do this quickly with sed.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'s/,/ /g'</span> AAPL.csv</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Date Open High Low Close Adj Close Volume</span><br><span class="line">2018-11-06 201.919998 204.720001 201.690002 203.770004 203.061493 31882900</span><br><span class="line">2018-11-07 205.970001 210.059998 204.130005 209.949997 209.219986 33424400</span><br><span class="line">2018-11-08 209.979996 210.119995 206.750000 208.490005 208.490005 25362600</span><br><span class="line"></span><br><span class="line">... omitted for brevity ...</span><br><span class="line"></span><br><span class="line">2019-02-04 167.410004 171.660004 167.279999 171.250000 171.250000 31495500</span><br><span class="line">2019-02-05 172.860001 175.080002 172.350006 174.179993 174.179993 36066500</span><br></pre></td></tr></table></figure>
<p>This will print the output of the sed transformation.  If I add the -i flag to the command, it will edit the file.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'s/,/ /g'</span> AAPL.csv</span><br></pre></td></tr></table></figure>
<p>Now that we have the file separated by spaces, we can look to <code>awk</code> to do some better summarization.  This data is a bit confusing in its current state because it has multiple versions of the stock price (open, high, low, close, adjusted).  I just want to see the date, open, and volume.  To get that, I can use awk.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">" "</span> <span class="string">' BEGIN &#123; print "Date\t\tPrice\t\tVolume" &#125;; NR &gt; 1 &#123; print $1 "\t" $2 "\t" $7 &#125; '</span> aapl.csv</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Date            Price           Volume</span><br><span class="line">2018-11-06      201.919998      31882900</span><br><span class="line">2018-11-07      205.970001      33424400</span><br><span class="line">2018-11-08      209.979996      25362600</span><br><span class="line"></span><br><span class="line">... omitted for brevity ...</span><br><span class="line"></span><br><span class="line">2019-02-04      167.410004      31495500</span><br><span class="line">2019-02-05      172.860001      36066500</span><br></pre></td></tr></table></figure>
<p>I know this command looks overly complex and difficult to learn and the purpose of this tutorial is not to make you an <code>awk</code> expert, but let’s take a moment to walk through the basic syntax of an awk command.  Once you know the basic syntax, a few Google searches will usually get you to the awk one-liner that you need for your given situation.</p>
<p>Awk is a bit of a tough command to learn because it is more of a programming language than a command line tool.  To learn what the command above means, let’s write it into a file for greater clarity.  I have created a file called <code>awk-example.sh</code> and placed the above command in it with better formatting.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is an awk comment</span></span><br><span class="line"><span class="comment"># Before processing any text, we want to set the FS variable (what our file is separated by), </span></span><br><span class="line"><span class="comment"># the OFS variable (what our output is separated by), and then print a header for our output.</span></span><br><span class="line">BEGIN &#123;</span><br><span class="line">        <span class="comment"># Notice how each line is ended with a semicolon -- similar to C programming language</span></span><br><span class="line">        FS=<span class="string">" "</span>;</span><br><span class="line">        OFS=<span class="string">"\t"</span>;</span><br><span class="line">        <span class="built_in">print</span> <span class="string">"Date\t\tPrice\t\tVolume"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># NR &gt; 1 means that we only want to print the following bracket enclosed values for lines that are greater</span></span><br><span class="line"><span class="comment"># than line 1.  In other words, we are omitting the first line.</span></span><br><span class="line">NR &gt; 1 &#123;</span><br><span class="line">        <span class="comment"># We want to print the first, second, and seventh value in each line.</span></span><br><span class="line">        <span class="built_in">print</span> <span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$7</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>We can run this file like so: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Outputs the same thing as </span></span><br><span class="line"><span class="comment"># awk -F " " ' BEGIN &#123; print "Date\t\tPrice\t\tVolume" &#125;; NR &gt; 1 &#123; print $1 "\t" $2 "\t" $7 &#125; ' aapl.csv</span></span><br><span class="line"><span class="comment"># This reads the awk-example.sh file and executes it against aapl.csv</span></span><br><span class="line">awk -f awk-example.sh aapl.csv</span><br></pre></td></tr></table></figure>
<p>As you might have noticed there are some built in variables to awk which include <code>FS</code> (file separator), <code>OFS</code> (output separator), <code>NR</code> (number of rows), and many more that can be <a href="https://www.tutorialspoint.com/awk/awk_built_in_variables.htm" target="_blank" rel="noopener">found here</a>.  We can use these variables rather than the command line flags.  For example, instead of writing <code>-F &quot; &quot;</code>, we can just set the <code>FS</code> variable in our awk file.</p>
<p>Learning <code>awk</code> entirely would take far more time than is warranted here in this tutorial, but if you can remember the basic syntax, you’ll be good to go.  Ultimately, each awk command is a series of keywords and outputs.  The command we just ran is shown below in this format.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># awk executable  Options   Keyword  What to print based on keyword          Keyword   What to print based on keyword file to run</span></span><br><span class="line">awk               -F <span class="string">" "</span> <span class="string">'  BEGIN    &#123; print "Date\t\tPrice\t\tVolume" &#125;;    NR &gt; 1    &#123; print $1 "\t" $2 "\t" $7 &#125; '</span> aapl.csv</span><br></pre></td></tr></table></figure>
<p>Awk can do much more than what has been shown including editing files.  A great introductory tutorial can be <a href="https://likegeeks.com/awk-command/" target="_blank" rel="noopener">found here</a>.</p>
<p>When push comes to shove, you generally do not need to be proficient in sed nor awk.  Perl/Python can do the same exact things with simpler syntax.  That said, knowing the basic usage of each can significantly speed up your workflow during those few moments where they do become necessary.  They can also become useful when you are writing a bash script and need a built-in text editor.  It would be inconvenient to break out of a bash script, run a python script, and then start your script again, so sed and awk provide nice alternatives to this workflow.</p>
<h3 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h3><p>Less is one of those command line utilities that you are probably not using and should be.  I find myself scrolling through large output all the time and forget that there is a command line utility that makes this a lot easier.  Less is simple to use, and works very similar to vim.  You can run less in two ways: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pipe output into less</span></span><br><span class="line">cat some-large-file.txt | less </span><br><span class="line"></span><br><span class="line"><span class="comment"># Use less directly</span></span><br><span class="line">less some-large-file.txt</span><br></pre></td></tr></table></figure>
<p>Once you are in less, your biggest asset is the <code>h</code> option.  Type <code>h</code> and you will receive a help panel with all the possible commands you can run.  I will go through some of the most useful and common.</p>
<ul>
<li>To scroll up a line, press <code>k</code> (like vim)</li>
<li>To scroll down a line, press <code>j</code> (like vim)</li>
<li>To go to end of file, press <code>G</code></li>
<li>To go to beginning of file, press <code>g</code></li>
<li>To search for “some text”, type <code>/some text</code> (to search forward) or `?</li>
<li>To go forward an entire window, type <code>f</code> or spacebar</li>
<li>To go back a window, press <code>b</code></li>
</ul>
<p>Just like grep, awk, and sed, scrolling and searching through output can be done in advanced text editors like VSCode fairly easily and if you have the opportunity to use these more advanced tools, go ahead and do so.  Using the <code>less</code> command is simply for those moments when those tools are not available to you.</p>
<h3 id="find-and-exec"><a href="#find-and-exec" class="headerlink" title="find and exec"></a>find and exec</h3><p>The find command is eerily similar to grep at first glance, but covers an entirely different use case.  You would need to use the find command when you want to search for certain files within the entire filesystem.  While grep searches for text in a file or a specified output, find searches explicitly for files in the filesystem.  Why is this useful?  Many times this command could be used to find the path where a specific executable is stored on the filesystem so you can edit, move, or remove it.  Maybe you installed a version of Python a long time ago and cannot remember where you downloaded it.  It is a common problem to have conflicting installations of Python on your machine.  It is also common to struggle to entirely remove Python from your machine.  Other uses for find could include: </p>
<ul>
<li>Find all of the .png files on your computer</li>
<li>Find all documents modified by some user in the last 7 days</li>
<li>Find any file that has a certain permission set</li>
</ul>
<p>As you can see, the possibilities here are endless and if used to its potential, the <code>find</code> command can solve a lot of issues that you never knew it could.  A quick example: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -<span class="built_in">type</span> f -size +1G</span><br></pre></td></tr></table></figure>
<p>This command will list all of the files on your computer that are greater than 1 Gigabyte in size.  If you’re low on disk space, this command will be your good friend and help you find those files that are taking up unecessary space on your computer.</p>
<p>The basic syntax for the find command is: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &lt;directory to search&gt; [options] &lt;file name to search&gt;</span><br></pre></td></tr></table></figure>
<p>Here are a few rapid-fire find commands to get you started.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Finds all jpg files on your system</span></span><br><span class="line">find / -<span class="built_in">type</span> f <span class="string">"*.jpg"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Finds all files modified in the last day</span></span><br><span class="line">find / -<span class="built_in">type</span> f -mtime 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find all files that belong to zach</span></span><br><span class="line">find / -<span class="built_in">type</span> f -user zach</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find all files with 777 permissions</span></span><br><span class="line">find / -<span class="built_in">type</span> f -perm 777</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find all files that start with the word config</span></span><br><span class="line">find / -<span class="built_in">type</span> f -name <span class="string">"config*"</span></span><br></pre></td></tr></table></figure>
<p>These are just a couple of the thousands of possibilities here.  Furthermore, you can use the <code>exec</code> command to take the <code>find</code> command to a new level.  Instead of just finding a bunch of files, you can perform operations on them.  Although very powerful, this also can be very dangerous if you are not careful.  The exec function will do as you might guess and execute a command on every single file that was found by <code>find</code>.  So if you combine the <code>find</code> and <code>rm</code> command together using <code>exec</code>, you may delete a bunch of files.  So before we get into it, be careful!</p>
<p>Here is a simple find command that will find all the jpg files in our home directory.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~/ -<span class="built_in">type</span> f -name <span class="string">"*.jpg"</span></span><br></pre></td></tr></table></figure>
<p>If we wanted to copy all the matches to a <code>~/pictures-backup</code> folder, you can add the exec command.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~/ -<span class="built_in">type</span> f -name <span class="string">"*.jpg"</span> -<span class="built_in">exec</span> <span class="string">'&#123;&#125;'</span> ~/pictures-backup \;</span><br></pre></td></tr></table></figure>
<p>You might be wondering what the <code>&#39;{}&#39;</code> and <code>\;</code> pieces of this command mean.  If you use your new skills, you can find more information about the <code>exec</code> command by piping the find man pages into less and searching for the word “exec”.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man find | less </span><br><span class="line">/-<span class="built_in">exec</span></span><br><span class="line">n <span class="comment"># repeats the search for -exec and finds next occurrence of it</span></span><br></pre></td></tr></table></figure>
<p>In these man pages, you can see that the <code>&#39;{}&#39;</code> is where the files that were found are placed in the command and <code>\;</code> is a character that tells the <code>exec</code> script to stop executing.  The backslash is just a safety mechanism.  You could also use <code>&#39;;&#39;</code>.  </p>
<p>After running this command, you now have all the jpg pictures in your entire home directory copied to a centralized backup repository!  You can begin to see how powerful this new command is!</p>
<h3 id="tar-gzip-gunzip"><a href="#tar-gzip-gunzip" class="headerlink" title="tar, gzip, gunzip"></a>tar, gzip, gunzip</h3><p>These utilities are fairly simple and used to compress and decompress files.  Many times when we download a software release or series of large files or images, we will get them in the <code>.tar</code>, <code>.gz</code>, or even <code>.tar.gz</code> formats.  <code>tar</code> and <code>gz</code> are slightly different.  <code>tar</code> is an archive format while <code>gz</code> is a compressed format.  Most of the time, we an rely on our computer’s file explorer to be able to handle these formats, but sometimes, we need to unzip or decompress them on the command line (think remote server).  Here are the most common commands.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a .tar format archive</span></span><br><span class="line"><span class="comment"># c is create mode, v is verbose output, f is tar format</span></span><br><span class="line">tar cvf archive.tar file1 file2 file3 ... filen</span><br><span class="line"></span><br><span class="line"><span class="comment"># List what is in .tar archive</span></span><br><span class="line"><span class="comment"># t is list mode</span></span><br><span class="line">tar tvf archive.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># To unpack a .tar file</span></span><br><span class="line"><span class="comment"># x is extract mode, v is verbose output, f is tar format</span></span><br><span class="line">tar xvf archive.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compress a file or archive</span></span><br><span class="line">gzip archive.tar <span class="comment"># creates archive.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncompress </span></span><br><span class="line">gunzip archive.tar.gz</span><br></pre></td></tr></table></figure>
<p>There a several more options you can explore, but these commands should get you started with compression/archive utilities.</p>
<h1 id="Advanced-Bash"><a href="#Advanced-Bash" class="headerlink" title="Advanced Bash"></a>Advanced Bash</h1><p>Not all of the following topics are solely bash concepts, but they are important to be aware of even if you are not going to be using them on a daily basis.  The breadth of concepts go to show the true power of the bash shell.  The topics are as follows.</p>
<ul>
<li>Regular expressions (used with scripting)</li>
<li>Bash Scripting</li>
<li>Virtual Machines and SSH </li>
<li>Networking on the command line</li>
<li>Process management</li>
<li>System Management</li>
</ul>
<h2 id="Regular-Expressions"><a href="#Regular-Expressions" class="headerlink" title="Regular Expressions"></a>Regular Expressions</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/NhcaKdt3NdM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>To me, regular expressions are often made far more complicated than they need to be. Sure, there are a lot of options and little details to learn regarding regular expressions, and on top of that, there are many different flavors of regular expressions (python, extended, rust, etc.).  Despite this, there are only a few core concepts that one must understand about regular expressions that will then translate in the ability to use any flavor of regular expressions effectively.</p>
<p>Regular expressions exist because a literal text searching program is sometimes not good enough.  Let me give you an extremely practical example from my own work to explain.</p>
<p>I recently wrote a script in Microsoft Excel VBA that executed commands from an external library.  The code of this external library was not available for me to see, and therefore, I had to use it with limited control.  As a result of this, the library would open up a new Excel workbook for every function call I made.  In each workbook, there was data that I needed to copy and paste into my main workbook, but in the code, I had no way of determining what the name of this new workbook was.  Luckily, Excel opens new workbooks and names them “Book1”, “Book2”, “Book3”, “Book4”, etc.  Knowing that these new workbooks would always contain the word “Book” at the beginning, I was able to use a regular expression to identify them.  My regular expression was quite simple, and looked like this: <code>^Book[0-9]+</code>.  I have not yet explained what this syntax means, but essentially, we are searching for text that starts with “Book” and ends with 1 or more numbers.  </p>
<p>A more common example for regular expressions is searching large documents for email addresses or phone numbers or even validating user input in a web application.  Chances are, you will not need to use regular expressions on a daily basis, so I am not going to teach you all the nitty gritty details that you will forget within a day.  Instead, I am going to teach you the methodology behind regular expressions that will give you a foundation to work with.  You may have to Google for help regarding specific use cases, but you will never have any confusion about regular expressions.</p>
<p>Let me first start by addressing the fact that there are many different versions of regular expressions.  Here are three different ways to use the same regular expression:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is how we use a javascript regular expression to match a string with 3 or more digits in it</span></span><br><span class="line"><span class="keyword">let</span> myRegExp = <span class="regexp">/[0-9]&#123;3,&#125;/</span></span><br><span class="line"><span class="keyword">let</span> myStringToMatch = <span class="string">'345'</span></span><br><span class="line"></span><br><span class="line">myRegExp.exec(myStringToMatch);  <span class="comment">// ["345", index: 0, input: "345", groups: undefined]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is the same regexp, but in Python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">result = re.search(<span class="string">'[0-9]&#123;3,&#125;'</span>, <span class="string">'345'</span>)</span><br><span class="line"></span><br><span class="line">print(result.group(<span class="number">0</span>)) <span class="comment"># '345'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># And finally, the same expression written in the bash shell using the grep command</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"345"</span> | grep -E <span class="string">'[0-9]&#123;3,&#125;'</span> <span class="comment"># 345</span></span><br></pre></td></tr></table></figure>
<p>As you can see, all three languages utilize regular expressions a bit differently, but the actual expression that we are writing in each is exactly the same.  Regular expressions are easily translatable from one language to the next.  </p>
<p>The easiest way to explain regular expressions is through practical examples and derivations of <em>why</em> we might need a regular expression for a given scenario.  Let us start with the following text.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I am some random text</span><br></pre></td></tr></table></figure>
<p>If I wanted to match the word “random” in this text, I could do this with a regular text searching tool.  For example, I could use grep in the following manner.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"I am some random text"</span> | grep <span class="string">"random"</span></span><br></pre></td></tr></table></figure>
<p>This is trivial and unexciting.  We all understand the basic concept of text matching, but sometimes don’t take a moment to think about what it really is.  If we were to write a text matching program, it would roughly follow these steps:</p>
<ol>
<li>Store our search string in a variable </li>
<li>Open our file to search</li>
<li>Read each character in the file one by one, seeing if that character matches the first character in our search string</li>
<li>If there is a match, advance to the next letter in the search string and check to see if that matches the next character in the file</li>
<li>If we reach the end of our search string without any errors, then we have matched the text</li>
</ol>
<p>This is an overly simplified explanation, but you can <a href="https://stackoverflow.com/a/1627904/7437737" target="_blank" rel="noopener">read more here</a> if you’re curious.  What I just explained is called “literal text matching” and can be done using any text searching utility.  It can also be done by a regular expression utility.  If we activate the Perl regular expressions feature of <code>grep</code>, we can find this same word.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"I am some random text"</span> | grep -P <span class="string">"random"</span></span><br></pre></td></tr></table></figure>
<p>If you’re wondering how this is any different from my original search, that’s good because there is no difference other than the <code>-P</code> flag which tells grep to interpret this as a regular expression.  At this point, we have concluded in the most anti-climactic way possible that regular expressions can carry out the basic function of literal text matching.  But this is exactly where regular expressions start to get interesting, because not only can they match literal strings of characters, but also <em>patterns</em> of characters in specified <em>quantities</em>.  I will elaborate on this as we move forward, but let’s start simple.  Let’s say that I had the following file of text called <code>http-request.txt</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Alt-Svc: quic=&quot;:443&quot;; ma=2592000; v=&quot;44,43,39&quot;</span><br><span class="line">Cache-Control: private, max-age=0</span><br><span class="line">Content-Encoding: br</span><br><span class="line">Content-Length: 72493</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Date: Mon, 11 Feb 2019 21:40:25 GMT</span><br><span class="line">Expires: -1</span><br><span class="line">Server: gws</span><br><span class="line">Set-Cookie: 1P_JAR=2019-02-11-21; expires=Wed, 13-Mar-2019 21:40:25 GMT; path=/; domain=.google.com</span><br><span class="line">Set-Cookie: SIDCC=AN0-TYtZ7bElYEE0wy8nAaXHUK_GRAsuZzNu7r5OhKVGKwr7a-m7ctz5IIHoZcvmh2s9xuDt0gc; expires=Sun, 12-May-2019 21:40:25 GMT; path=/; domain=.google.com; priority=high</span><br><span class="line">Strict-Transport-Security: max-age=31536000</span><br><span class="line">X-Frame-Options: SAMEORIGIN</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line"></span><br><span class="line">Alt-Svc: quic=&quot;:443&quot;; ma=2592000; v=&quot;44,43,39&quot;</span><br><span class="line">Cache-Control: private, max-age=0</span><br><span class="line">Content-Encoding: br</span><br><span class="line">Content-Length: 72470</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Date: Mon, 11 Feb 2019 21:44:38 GMT</span><br><span class="line">Expires: -1</span><br><span class="line">Server: gws</span><br><span class="line">Set-Cookie: 1P_JAR=2019-02-11-21; expires=Wed, 13-Mar-2019 21:44:38 GMT; path=/; domain=.google.com</span><br><span class="line">Set-Cookie: SIDCC=AN0-TYsHoOeMCDEAZfNd9umwLDXDEHqyGfAImuc08v4h2e1B1hSKxGQAq7iVt0xFlQKLzVlgSTM; expires=Sun, 12-May-2019 21:44:38 GMT; path=/; domain=.google.com; priority=high</span><br><span class="line">Strict-Transport-Security: max-age=31536000</span><br><span class="line">X-Frame-Options: SAMEORIGIN</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line"></span><br><span class="line">Alt-Svc: quic=&quot;:443&quot;; ma=2592000; v=&quot;44,43,39&quot;</span><br><span class="line">Cache-Control: private, max-age=0</span><br><span class="line">Content-Encoding: br</span><br><span class="line">Content-Length: 72464</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Date: Mon, 11 Feb 2019 21:46:36 GMT</span><br><span class="line">Expires: -1</span><br><span class="line">Server: gws</span><br><span class="line">Set-Cookie: 1P_JAR=2019-02-11-21; expires=Wed, 13-Mar-2019 21:46:36 GMT; path=/; domain=.google.com</span><br><span class="line">Set-Cookie: SIDCC=AN0-TYuz2RnQRkvCL-vKi53aZ9wq43igGogt5iPF1aveuchWK1_5cZsxzom9-PWiJjy8Sk7bvgY; expires=Sun, 12-May-2019 21:46:36 GMT; path=/; domain=.google.com; priority=high</span><br><span class="line">Strict-Transport-Security: max-age=31536000</span><br><span class="line">X-Frame-Options: SAMEORIGIN</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br></pre></td></tr></table></figure>
<p>Above are three <em>separate</em> HTTP response headers from three separate requests I made to <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a>.  As you can see, they all follow a similar data structure, but are not considered “structured” data of any kind.  This is a perfect set of text for us to use to learn regular expressions.  Let’s say I wanted to get the date and time of each request in this file.  I could easily find these 3 lines (each request has a date) using a regular expression.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat http-request.txt | grep -P <span class="string">"^Date.+"</span></span><br></pre></td></tr></table></figure>
<p>When executed, this command will find and print out the three date lines.  The “Date” part of the regex makes sense, but what does the “.+” mean?  What is the <code>^</code> at the beginning?  If we omit these two characters, we will match the word “Date” 3 times, but we won’t get the actual date information that we really want.  This is a perfect opportunity to introduce the “metacharacters”.  In regular expressions, the following characters will behave a bit oddly: <code>. ^ $ * + ? { } [ ] \ | ( )</code></p>
<p>If you understand what each of these characters do, you understand how to use regular expressions.  When reading through a file, a regular expression will go line by line (each line indicated by the <code>\n</code> character).  When you write a regex, it will be tested against every line of the file.  Knowing this, we can conclude that the “boundary” for a regular expression is just a single line.  In some cases, it may be useful if we had a way of matching text at the beginning or end of a line.  For example, with a list of phone numbers, we might look for a specific area code.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">234-234-1920</span><br><span class="line">121-726-1382</span><br></pre></td></tr></table></figure>
<p>In line 1, the area code is the same as the middle three numbers.  By using the <code>^</code> character in our regular expression, we can isolate just the first three characters.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat phone-numbers.txt | grep -P <span class="string">"^234"</span></span><br></pre></td></tr></table></figure>
<p>This regular expression will match just the area code of the first phone number.  Now, let’s say that we want to match all the lines of text that end in a question mark.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sentences.txt</span><br><span class="line"></span><br><span class="line">The regex will not match me.</span><br><span class="line">The regex will not match me either.</span><br><span class="line">But wouldn&apos;t it make sense that the regex matched me?</span><br></pre></td></tr></table></figure>
<p>Remember, the <code>?</code> is a special character, so we must “escape it” using the backslash.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat sentences.txt | grep -P <span class="string">".+\?$"</span></span><br></pre></td></tr></table></figure>
<p>This regex will match the entire line that ends in a question mark because we are using the <code>$</code> symbol, which represents the end of the line.  This is opposite of the <code>^</code> character that we just learned about.</p>
<p>At this point, you’ve probably already looked up what that period <code>.</code> character does in a regex.  When used in a regex, the <code>.</code> matches all characters except the newline character (remember, regular expressions use that to determine where the end of a line is?). There are also three other “special” characters that we can use to match certain types of characters.</p>
<ul>
<li><code>.</code> - matches any character</li>
<li><code>\d</code> - matches any digit (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)</li>
<li><code>\s</code> - matches any whitespace character (including newlines)</li>
<li><code>\w</code> - matches any alphanumeric character (letters and numbers)</li>
</ul>
<p>If you capitalize <code>\D</code>, <code>\S</code>, and <code>\W</code>, it negates the expression.  Using this new knowledge, let’s try to match the following line of text.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You cannot match me because you don&apos;t know what a quantifier is!</span><br></pre></td></tr></table></figure>
<p>If we tried to match this line using just the skills we know now, we might try something like so: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"You cannot match me because you don't know what a quantifier is"</span> | grep -P <span class="string">"^Youis$"</span></span><br></pre></td></tr></table></figure>
<p>Shouldn’t this work?  We are matching “You” at the beginning of the line (<code>^</code>) and “is” at the end of the line (<code>$</code>).  The problem is… We failed to match all those words and letters in the middle.  So maybe if we add the <code>.</code> in the middle it will match all of them!  Let’s try it.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"You cannot match me because you don't know what a quantifier is"</span> | grep -P <span class="string">"^You.is$"</span></span><br></pre></td></tr></table></figure>
<p>Unfortunately, this isn’t going to work either.  The reason this isn’t working is because we have not specified <em>how many</em> characters we want to match between the literal word “You” and the literal word “is!”.  To do this, we can use either <code>*</code>, <code>+</code>, <code>?</code>, or <code>{}</code>.</p>
<ul>
<li><code>*</code> - Matches 0 or more of the preceding character</li>
<li><code>+</code> - Matches 1 or more of the preceding character</li>
<li><code>?</code> - Matches 0 or 1 of the preceding character</li>
<li><code>{1}</code> - Matches exactly 1 of the preceding character</li>
<li><code>{1,}</code> - Matches 1 or more of the preceding character (identical to <code>+</code>)</li>
<li><code>{2,6}</code> - Matches between 2 and 6 of the preceding character</li>
</ul>
<p>These are what we call “quantifiers”, and they are extremely important.  As you might have noticed, you can write <em>any</em> quantifier using the <code>{}</code> brackets alone, but sometimes, the <code>*</code>, <code>+</code>, and <code>?</code> are quicker and cleaner to write.  With these quantifiers, we can complete our expression.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"You can match me now because you know what a quantifier is"</span> | grep -P <span class="string">"^You.+is$"</span></span><br></pre></td></tr></table></figure>
<p>To recap, we are matching “You” at the beginning of the line (<code>^</code>), then we are matching 1 or more of <em>any</em> character after that (<code>.+</code>), and finally we are matching “is” at the end of the line (<code>$</code>).  Below are a few examples that demonstrate the use of quantifiers.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Single letter</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^a"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^a+"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^a*"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^a?"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^a&#123;1&#125;"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^a&#123;1,&#125;"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^a&#123;0,1&#125;"</span> <span class="comment"># matches!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Double letter</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"aa"</span> | grep -P <span class="string">"^a"</span> <span class="comment"># Only matches first letter</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"aa"</span> | grep -P <span class="string">"^a+"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"aa"</span> | grep -P <span class="string">"^a*"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"aa"</span> | grep -P <span class="string">"^a?"</span> <span class="comment"># Only matches the first letter</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"aa"</span> | grep -P <span class="string">"^a&#123;1&#125;"</span> <span class="comment"># Only matches the first letter</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"aa"</span> | grep -P <span class="string">"^a&#123;1,&#125;"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"aa"</span> | grep -P <span class="string">"^a&#123;0,1&#125;"</span> <span class="comment"># Only matches the first letter</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"aa"</span> | grep -P <span class="string">"^a&#123;0,1&#125;$"</span> <span class="comment"># Does not match at all!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Using metacharacters</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\w"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\w+"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\w*"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\w?"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\w&#123;1&#125;"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\w&#123;1,&#125;"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\w&#123;0,1&#125;"</span> <span class="comment"># matches!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Another use of metacharacters (matching anything that is not a digit)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\D"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\D+"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\D*"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\D?"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\D&#123;1&#125;"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\D&#123;1,&#125;"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a"</span> | grep -P <span class="string">"^\D&#123;0,1&#125;"</span> <span class="comment"># matches!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 10 different ways to match the same word</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"regexp"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"^regexp"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"^reg\w*"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"^reg\w*$"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"^\w*$"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"\w*"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"^\w+"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"^regex\w?$"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"\D&#123;1,&#125;"</span> <span class="comment"># matches!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"^\S&#123;1&#125;\w+$"</span> <span class="comment"># matches!</span></span><br></pre></td></tr></table></figure>
<p>As you can see in the last couple lines, there are many ways to match the same text.  We could probably find 40 different regular expressions that all match the line “regexp”.  And that is not even considering the last metacharacter that we are going to cover!  This entire time, I have not even mentioned “character classes”, which are expressions contained within <code>[]</code>.  The reason I skipped over these is because when we use them, all the rules change.  The metacharacters (<code>. ^ $ * + ? { } [ ] \ | ( )</code>) will all behave differently when placed inside brackets, and furthermore, you can write an adequate regular expression without them 99% of the time!  That said, character classes make your life easier in many cases, so we need to cover them at least briefly.  </p>
<p>You can think of a character class as a single character, but with multiple possibilities.  For example, the following character class represents every lowercase letter in the alphabet, but only 1 of them since we added a quantifier - <code>[a-z]{1}</code>.  We could also define only the first 13 letters of the alphabet like so - <code>[a-m]</code>.  This extends to digits too.  <code>[0-9]</code> represents every possible digit, and is exactly equivalent to <code>\d</code>.  <code>[0-9a-zA-Z_]</code> represents all alphanumeric characters and is exactly equivalent to <code>\w</code>.</p>
<p>You might be wondering why you would ever need something like <code>[0-9]</code> when you could just use <code>\d</code>, and you are wondering for good reason!  These character classes are not necessary in most cases and I would encourage you to use <code>\d</code> rather than <code>[0-9]</code> whenever possibly for utmost brevity.  That said, there are certain situations where this could be useful.  Maybe you want to only match numbers 1-5.  There is no abbreviation for the character class <code>[1-5]</code> and therefore we must utilize it.</p>
<p>When using character classes, there are a few “gotchas” that we need to cover.  They all relate to the use of metacharacters and how those metacharacters behave in a character class.  In general, I would not recommend trying to use any metacharacter inside a character class (<code>[]</code>), but if you do, here are the rules.</p>
<ul>
<li>The <code>^</code> character does not mean the beginning of a line.  It is a negation symbol.  </li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This expression will match. The first ^ means "beginning of line" while the </span></span><br><span class="line"><span class="comment"># second ^ (inside the brackets) means "not".  Therefore, this expression</span></span><br><span class="line"><span class="comment"># will match 1 or more characters starting at the beginning of the line that </span></span><br><span class="line"><span class="comment"># are not digits. </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"^[^0-9]+"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>The <code>.</code> character matches literally inside brackets</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># You might think that this will match, but it does not.  This expression matches</span></span><br><span class="line"><span class="comment"># 1 or more period characters starting at the beginning of the line.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp"</span> | grep -P <span class="string">"^[.]+"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This expression does match!</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"regexp..."</span> | grep -P <span class="string">"^regexp[.]+"</span></span><br></pre></td></tr></table></figure>
<p>Finally, I want to briefly mention why I never talked about the metacharacters <code>|</code> and <code>()</code>.  These both relate to the topic of “groups”, which allows you to group different parts of your regular expression.  If your regular expression is a really long one, it is often helpful to group off different sections of it.  The reason I did not cover this topic is because this topic is far more useful if you are using a programming language like Python for regular expressions because with such a language, you can refer to different groups of your regular expression later in your code.  Since we are learning regular expressions in bash, we generally don’t need or have this functionality.</p>
<p>So…</p>
<p>The ultimate conclusion about regular expressions?? </p>
<p><em>There are MANY ways to write them</em>.</p>
<p>The remainder of this section will walk through a practical example using our newfound regexp skills.  I have attempted to solve the problem two different ways using two different types of regexp syntax to demonstrate that there is more than one way to do things.</p>
<h3 id="Detailed-Example-Regular-Expression"><a href="#Detailed-Example-Regular-Expression" class="headerlink" title="Detailed Example Regular Expression"></a>Detailed Example Regular Expression</h3><p>Let’s say we had the following file called <code>email-addresses.txt</code>: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jon23@gmail.com</span><br><span class="line">bob879@yahoo.com</span><br><span class="line">not an email</span><br><span class="line">sally2@customsite.com</span><br><span class="line">fred.jones@hotmail.com</span><br><span class="line">not an email address</span><br></pre></td></tr></table></figure>
<p>Learning how to match all four of the emails with a single regular expression will demonstrate a lot of the concepts that we have covered.  We start by matching all characters with the <code>.</code> metacharacter starting at the beginning of each line (<code>^</code>). </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat email-addresses.txt | grep -P <span class="string">"^.+"</span></span><br></pre></td></tr></table></figure>
<p>The expression we just wrote means that we are starting at the beginning of each line and looking for <em>any</em> character except line breaks in a quantity of 1 or more characters.  We could easily have written the same expression differently like so: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat email-addresses.txt | grep -P <span class="string">"^[^\r\n]&#123;1,&#125;"</span></span><br></pre></td></tr></table></figure>
<p>As you can see, regular expressions can be used in a multitude of ways.  In this version, we are doing the <em>same</em> thing we did above with different syntax.  The <code>^</code> still indicates that we are looking at the beginning of each line.  The <code>[^\r\n]</code> means that we are matching <em>any</em> character that is <em>not</em> (<code>^</code>) a carriage return or new line (<code>\r</code>, <code>\n</code>).  Notice how when we place the <code>^</code> inside the character set it now acts as a negation rather than “search from the beginning of the line”.  Remember, symbols behave differently when placed inside a character set, so be careful!  Finally, we want to match these characters 1 or more times, so we use the <code>{1,}</code> syntax.  The comma after the 1 indicates that we want 1 or <em>more</em> matches.  Anyways, if we run this, we will again match all six lines of the text file.  Since we only want to match the email addresses, we will need to tweak the expression.  Moving forward, I will be writing two regular expressions with different syntax that <strong>both do the same things</strong>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat email-addresses.txt | grep -P <span class="string">"^[^\r\n]&#123;1,&#125;@.&#123;1,&#125;"</span></span><br><span class="line">cat email-addresses.txt | grep -P <span class="string">"^.+@.+"</span></span><br></pre></td></tr></table></figure>
<p>The two expressions above both match the four email addresses while excluding the other two lines.  All we had to do was add an “@” symbol followed by the same thing we had before the symbol.  This is great, but what if we modified the text file so it looked like this: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jon23@gmail.com</span><br><span class="line">bob879@yahoo.com</span><br><span class="line">not an email</span><br><span class="line">sally2@customsite.com</span><br><span class="line">this line has an @ symbol in it so it will mess with our regex</span><br><span class="line">fred.jones@hotmail.com</span><br><span class="line">not an email address</span><br></pre></td></tr></table></figure>
<p>Now when we run our regular expressions, we will match all the email addresses and the new line that I added.  As you can see, depending on the complexity of the text you are searching, you may have to go through some trial/error before you get the right regular expression for the job.  In this case, we are going to need to modify the back half of the regular expression to the following.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat email-addresses.txt | grep -P <span class="string">"^[^\r\n]&#123;1,&#125;@.&#123;1,&#125;\.com"</span></span><br><span class="line">cat email-addresses.txt | grep -P <span class="string">"^.+@.+\.com"</span></span><br></pre></td></tr></table></figure>
<p>We are now matching just the email addresses again.  All I did was add <code>\.com</code> at the end of our regular expression for a <em>literal</em> match (we had to “escape” the period here because otherwise it refers to all characters as it did earlier in the expression.  To escape a special character, we use the backslash right before it).  But what if I modified the text file one more time like so?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jon23@gmail.com</span><br><span class="line">bob879@yahoo.com.yahoo.com</span><br><span class="line">not an email</span><br><span class="line">sally2@customsite.net</span><br><span class="line">this line has an @ symbol in it so it will mess with our regex</span><br><span class="line">fred.jones@hotmail.com</span><br><span class="line">not an email address</span><br></pre></td></tr></table></figure>
<p>I made two changes here.  First, I made one of the email addresses invalid.  “<a href="mailto:bob879@yahoo.com.yahoo.com" target="_blank" rel="noopener">bob879@yahoo.com.yahoo.com</a>“ is obviously an invalid email and we do not want to match it.  Second, “<a href="mailto:sally2@customsite.net" target="_blank" rel="noopener">sally2@customsite.net</a>“ no longer has “.com” at the end, so this will not match our regexp.  Here is how we would modify the regular expressions to match only the valid email addresses.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat email-addresses.txt | grep -P <span class="string">"^[^\r\n]&#123;1,&#125;@[a-zA-Z0-9]&#123;1,&#125;(.com|.net)&#123;1&#125;"</span></span><br><span class="line">cat email-addresses.txt | grep -P <span class="string">"^.+@\w+(.com|.net)&#123;1&#125;"</span></span><br></pre></td></tr></table></figure>
<p>The above regular expressions will get us a lot closer.  In both expressions, we replaced <code>\.com</code> with <code>(.com|.net){1}</code> to match <em>either</em> “.com” or “.net” email addresses exactly once.  Then, in the first regex, we replaced <code>.{1,}</code> with <code>[a-zA-Z0-9]{1,}</code> which will now not match the “yahoo.com.yahoo.com” because the periods do not match the character set.  Likewise, we changed the second regular expression from <code>.+</code> to <code>\w+</code>, which does the same thing.  The only problem we face now is that the regular expressions are still matching the first part of the “<a href="mailto:bob879@yahoo.com.yahoo.com" target="_blank" rel="noopener">bob879@yahoo.com.yahoo.com</a>“.  We do not want to match this line <em>at all</em>.  To fix this, we modify the regular expressions one more time.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat email-addresses.txt | grep -P <span class="string">"^[^\r\n]&#123;1,&#125;@[a-zA-Z0-9]&#123;1,&#125;(.com|.net)&#123;1&#125;$"</span></span><br><span class="line">cat email-addresses.txt | grep -P <span class="string">"^.+@\w+(.com|.net)&#123;1&#125;$"</span></span><br></pre></td></tr></table></figure>
<p>All I did was add the <code>$</code> character at the end of each expression.  Just like we have the <code>^</code> at the beginning of each expression, we can place the <code>$</code> at the end of the expressions to indicate we have reached the end of our line.  This will eliminate that invalid email address!</p>
<h2 id="Bash-Scripting"><a href="#Bash-Scripting" class="headerlink" title="Bash Scripting"></a>Bash Scripting</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/JdvG_H07CNc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>Throughout this tutorial, we have covered many commands and concepts.  Most of the commands we have learned (with the exception of the <code>awk</code>) command are for strict usage on the command line, but what if you wanted to put some of these in a script to run?  You could always write out a long and elaborate command and execute it, but it will not get saved and is difficult to write.  Bash scripting solves this problem by allowing you to write common bash commands within a script file and then execute that script file.  You may find this useful if you need to do something on a periodic basis.  For example, maybe you need to clean out a specific folder on your computer every day and place the contents of it in an archived folder with today’s date on it.  You can do this through bash scripting, and in this brief introduction, I will teach you how to do just that.  First, we need to understand the basics of a scripting file.</p>
<p>The most basic form of a scripting file is shown below.  This file is called <code>simple-script.sh</code> where the <code>.sh</code> is the file extension for the script (not necessary, but good practice).  The permissions on this file are <code>744</code>, which means that only we (the owner of the script) can modify or execute it.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"I am a useless, basic script"</span></span><br></pre></td></tr></table></figure>
<p>To run this, we can do so in two ways.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash simple-script.sh </span><br><span class="line"></span><br><span class="line">./simple-script.sh</span><br></pre></td></tr></table></figure>
<p>Notice that the top of the file has something called a “shebang” (<code>#!/bin/bash</code>), which tells the interpreter which executable to run the script against.  In this case, we are telling it to run with the bash shell which is stored in <code>/bin</code> on our machine.  As a note, you generally do not need this shebang as in most cases, your bash shell will execute the scripts by default with bash, but it is good practice and increases portability if you add it.</p>
<p>This is the most basic form of a script, but obviously not all that useful.  Throughout this section, we will learn the most important components of a bash script, which includes: </p>
<ul>
<li>Variable declarations</li>
<li>Built-in variables</li>
<li>Command line arguments</li>
<li>Reading user input</li>
<li>for loops</li>
<li>if-then statements</li>
</ul>
<p>With these concepts, you should be able to accomplish 95% of your tasks.  Sure, there will be times where the above concepts are not enough, but again, this is an introduction to scripting rather than a deep dive.  For the rest of this section, you can assume that I have replaced the contents of a file called <code>shell-scripting-basics.sh</code> every time I run a script unless otherwise noted.</p>
<h3 id="Variable-declarations"><a href="#Variable-declarations" class="headerlink" title="Variable declarations"></a>Variable declarations</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MY_VARIABLE=<span class="string">"some value"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$MY_VARIABLE</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Variables can also be added within double-quoted strings: <span class="variable">$MY_VARIABLE</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'But not single-quoted strings. This will not read the variable: $MY_VARIABLE'</span></span><br></pre></td></tr></table></figure>
<p>Declaring and using variables is rather simple in bash scripting, so I will not spend a lot of time here.</p>
<h3 id="Built-In-Variables"><a href="#Built-In-Variables" class="headerlink" title="Built-In Variables"></a>Built-In Variables</h3><p>There are several built in variables that you can use in a bash script.  They are listed below.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$0</span>  <span class="comment"># Prints the name of the script - shell-scripting-basics.sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span>  <span class="comment"># Prints the first argument given to a script</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$2</span>  <span class="comment"># Prints the second argument given to a script </span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$3</span>  <span class="comment"># Prints the third... do I need to continue here??? </span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$#</span>  <span class="comment"># Prints the number of arguments passed to the script</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$@</span>  <span class="comment"># Prints all arguments passed to the script</span></span><br><span class="line"><span class="built_in">echo</span> $$  <span class="comment"># Prints the process ID</span></span><br><span class="line"><span class="built_in">echo</span> $?  <span class="comment"># Prints the exit code of the previous process run</span></span><br></pre></td></tr></table></figure>
<h3 id="Command-Line-Arguments"><a href="#Command-Line-Arguments" class="headerlink" title="Command Line Arguments"></a>Command Line Arguments</h3><p>A shell script can take arguments on the command line.  For example, if I ran the following script: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The script <span class="variable">$0</span> evaluates to: "</span> $((<span class="variable">$1</span>+<span class="variable">$2</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./shell-scripting-basics.sh 3 9</span><br><span class="line"></span><br><span class="line"><span class="comment"># The script ./shell-scripting-basics.sh evaluates to:  12</span></span><br></pre></td></tr></table></figure>
<p>This script will evaluate to - “The script ./shell-scripting-basics.sh evaluates to:  12”</p>
<p>As you can see, we can use the built-in variables inside our scripts.</p>
<h3 id="Reading-user-input"><a href="#Reading-user-input" class="headerlink" title="Reading user input"></a>Reading user input</h3><p>We can also read user input from a script.  This is similar to reading arguments, but instead of the user typing their input in before execution time, they type it in during execution.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reading the user's input into the user_input variable</span></span><br><span class="line"><span class="built_in">read</span> user_input</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The user entered: <span class="variable">$user_input</span>"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./shell-scripting basics</span><br><span class="line">some input</span><br><span class="line">The user entered: some input</span><br></pre></td></tr></table></figure>
<p>If you want to protect the user input (ex: password entry), just add an <code>-s</code> at the beginning of the command like so: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> -s user_input</span><br></pre></td></tr></table></figure>
<h3 id="for-loops"><a href="#for-loops" class="headerlink" title="for loops"></a>for loops</h3><p>The syntax for looping in bash is: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="variable">$@</span>; <span class="keyword">do</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$item</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>In this script, we are looping through all of the user arguments provided to the script.  Remember, <code>$@</code> is a built-in variable containing all of the user arguments.  We can also define an array of variables in bash and loop through them.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">declare</span> -a my_array=(<span class="string">'string 1'</span>, <span class="string">'string 2'</span>, <span class="string">'string 3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;my_array[@]&#125;</span>"</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$item</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>The syntax for an array is a bit weird in bash as you can see.  We can also use the for loop syntax to loop through a bunch of files.  This is a common type of script that you might have to write.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Navigate to the home directory</span></span><br><span class="line"><span class="built_in">cd</span> ~/</span><br><span class="line"></span><br><span class="line"><span class="comment"># The * refers to all the files and directories in the current directory</span></span><br><span class="line"><span class="comment"># This script is basically the `ls` command</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> *; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$item</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="if-then-statements"><a href="#if-then-statements" class="headerlink" title="if-then statements"></a>if-then statements</h3><p>I saved if-then statements for last because they can get a bit complicated.  The testing syntax that we use for an if-then statement comes from the <code>test</code> command, and you can find all of the possibilities on the man page by typing <code>man test</code>.  For most commands in bash, the man pages are difficult to digest and are generally unhelpful for finding quick answers, but the man page for the <code>test</code> command is super straightforward and simple.  Therefore, I will not be listing out all of the available testing options and will assume you have read through the man page for <code>test</code>.  Below is a simple use of <code>test</code> on the command line (outside of a script).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> 2 -eq 2; <span class="built_in">echo</span> $?</span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> 2 -eq 3; <span class="built_in">echo</span> $?</span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<p>If you run these two commands, you will get output of 0 and 1.  As we talked about, these numbers are the exit codes of the test commands and are stored in the built-in variable <code>$?</code>.  Each line shown above is actually two commands.  First, we test a condition, and second, we print the exit code of the previous command (which was test).  If we want to place a test in a script for an if-then statement, we can write it like so: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ 2 -eq 2 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"2 does equal 2!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>This will print “2 does equal 2” because the expression evaluates to true (a 0 exit code).  We can also test other conditions.  For example, we can loop through all the files in our home directory and if they are directories, we will print “$name is a directory” and if not, “$name is a file”.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> *; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ -d <span class="variable">$name</span> ]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"<span class="variable">$name</span> is a directory!"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"<span class="variable">$name</span> is a file!"</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>The <code>-d</code> flag will test whether a given name is a directory.  If it is, it returns true (0 exit code).</p>
<p>Now that you know the basics of bash scripting, we can get to the practical example of checking a specific folder for files and moving them to an archive.  In this case, I will be checking a directory for files that have not been modified for 7 days or more and placing them in an archive folder named with today’s date.  This will incorporate the <code>find</code> command that we learned earlier!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"></span><br><span class="line">todays_date=$(date +%Y-%m-%d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># First check if the archives folder exists</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">'/home/zach/archives/'</span> ]; <span class="keyword">then</span></span><br><span class="line">	mkdir /home/zach/archives/</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Check if today's folder is already created</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">"/home/zach/archives/<span class="variable">$todays_date</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">	mkdir /home/zach/archives/<span class="variable">$todays_date</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A bit of a tricky expression here.  I looked up on StackOverflow how to pipe the output of the find command</span></span><br><span class="line"><span class="comment"># into a do-while loop because the find exec command gets a permission denied error when running it as a script</span></span><br><span class="line">find /home/zach/folder-to-clean -<span class="built_in">type</span> f -mtime -7 | </span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> filename</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">	mv <span class="variable">$filename</span> /home/zach/archives/<span class="variable">$todays_date</span>/</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>A programming language is not a language without functions, so here is the basic syntax for writing and then later calling a function in your bash script.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">some_function</span></span> () &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># If you pass arguments to me, I can print them</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">                <span class="comment"># No arguments were passed to function</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"I am a function and no arguments were passed to me"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="comment"># At least 1 argument was passed to me, so i will print all of them</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"here"</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">$@</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># I can return a value that can be retrieved later with the $? built-in variable</span></span><br><span class="line">        <span class="built_in">return</span> 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># calling our function</span></span><br><span class="line">some_function</span><br><span class="line"></span><br><span class="line"><span class="comment"># calling our function with arguments</span></span><br><span class="line">some_function <span class="string">"argument 1"</span> <span class="string">"argument 2"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Printing the return value of 20</span></span><br><span class="line"><span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>
<p>There are endless possibilities to writing bash scripts.  Play around a bit and you will be on your way!</p>
<h2 id="Virtual-Machines-and-SSH-Protocol"><a href="#Virtual-Machines-and-SSH-Protocol" class="headerlink" title="Virtual Machines and SSH Protocol"></a>Virtual Machines and SSH Protocol</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/wWrQdkoBZEI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>This topic can get quite loaded, and therefore I am not going to dig too deep into it.  We will cover the following: </p>
<ul>
<li>How to setup a public and private keypair for ssh access</li>
<li>Adding your keys to the ssh-agent (if applicable)</li>
<li>How to use SSH to connect to a remote machine</li>
<li>How to transfer files between your local machine and remote machine using <code>scp</code></li>
<li>How to download files from the internet</li>
<li>How to use VSCode with your VPS</li>
</ul>
<p>I primarily use Digital Ocean for my hosting needs, so I will be going through a tutorial on how to setup and connect to a virtual private server on Digital Ocean.  That said, the concepts apply across the board whether you are using AWS, Azure, etc.  When you first create a VPS in Digital Ocean (also called a “Droplet”), it will ask you whether you want to connect to the machine using a password or SSH key.  I almost always connect via an SSH key, so let’s first learn how to create that key on our local computer.  The process of connecting to a VPS works in the following steps.</p>
<ol>
<li>User creates a private/public SSH keypair on their local computer</li>
<li>User inputs the <em>public</em> key into the SSH field of their hosting provider while setting up the host</li>
<li>When user tries to connect to the host via SSH, the SSH tool will validate the private/public keypair stored on the local computer in the <code>~/.ssh</code> directory with the public key stored on the VPS.</li>
<li>If the keys validate, the user now gets remote access to the VPS, and your IP address is stored as a “known host” on the VPS.</li>
</ol>
<p>So the first step requires us to create a public/private keypair.  We can do this on Mac/Linux using the OpenSSH tool.  In your terminal, type the following command.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
<p>This will ask you what directory to store the key in.  For this to work, you need to put it in the <code>~/.ssh</code> folder, but you can give it any custom name.  When the command asks you for a password, just press enter twice without entering anything because we do not need to password protect the key since we are using our personal computer.  My new key is stored as <code>/home/zach/.ssh/id_digitalocean_rsa</code>.</p>
<p>You now need to print out and copy the public version of this key.  In my case, I type the command: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_digitalocean_rsa.pub</span><br></pre></td></tr></table></figure>
<p>Notice how I added <code>.pub</code> at the end.  When you create a keypair, there will be a <code>.pub</code> version always.  Once you have copied the contents of this file, paste it into the SSH key box on your hosting provider.  On Digital Ocean, I will paste it here.</p>
<img src="/blog/2019/bash-essentials/digital-ocean-key.png">
<p>Once you have done that, you can create your virtual machine.  Now, find the IP address of your new virtual machine and type the following command into your terminal.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 22 root@157.230.167.2</span><br></pre></td></tr></table></figure>
<p>This should successfully log you into your VPS.  </p>
<h3 id="Permanently-Add-Keys-to-ssh-agent"><a href="#Permanently-Add-Keys-to-ssh-agent" class="headerlink" title="Permanently Add Keys to ssh-agent"></a>Permanently Add Keys to ssh-agent</h3><p>This is generally not a problem on Linux, but on Mac, you will need to alter a few of the default settings.  By default, any key that is not <code>id_rsa</code> will not be added to the ssh-agent utility, and not the Mac keychain.  This means that every time you want to login to your VM, you will have to add the ssh key.  For example, I have a key called <code>digital-ocean</code> that I use for logging in to my digital ocean droplets.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Loads necessary environment variables</span></span><br><span class="line"><span class="built_in">eval</span> `ssh-agent -s`</span><br><span class="line"></span><br><span class="line"><span class="comment"># Adds ssh key</span></span><br><span class="line">ssh-add -K ~/.ssh/digital-ocean</span><br><span class="line"></span><br><span class="line"><span class="comment"># Login</span></span><br><span class="line">ssh -p 22 root@&lt;some-ip-address&gt;</span><br></pre></td></tr></table></figure>
<p>To avoid doing this every time you login to your Mac, you will need to modify <code>~/.ssh/config</code> to have the following entry: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">  UseKeychain yes</span><br><span class="line">  AddKeysToAgent yes</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br><span class="line">  IdentityFile ~/.ssh/digital-ocean</span><br></pre></td></tr></table></figure>
<p>Above, you are specifying a host of “everything” (you could replace with a domain such as github.com), and telling the agent to use the keychain, add keys, and use the two identity files listed as logins.</p>
<h3 id="From-local-computer-to-remote-machine"><a href="#From-local-computer-to-remote-machine" class="headerlink" title="From local computer to remote machine"></a>From local computer to remote machine</h3><p>Next, I want to show how to transfer files to and from your remote machine and local computer.  To do this, we use the <code>scp</code> utility.</p>
<p>If I had <code>sample-file.txt</code>, the way I would upload this to my remote machine is like so: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r sample-file.txt root@157.230.167.2:~/</span><br></pre></td></tr></table></figure>
<p>This will upload the <code>sample-file.txt</code> file using the <code>root</code> user and place that file in the home directory <code>~/</code> on my remote machine.  You can specify any path to place it on your remote machine so long as you put a colon <code>:</code> after the IP address.</p>
<h3 id="From-remote-machine-to-local-computer"><a href="#From-remote-machine-to-local-computer" class="headerlink" title="From remote machine to local computer"></a>From remote machine to local computer</h3><p>To download that same file from your remote machine to your local computer, you would just run the following.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r root@157.230.167.2:~/sample-file.txt ~/Downloads</span><br></pre></td></tr></table></figure>
<p>This will place that same sample file into my local computer’s <code>~/Downloads</code> folder.</p>
<h3 id="Downloading-packages-to-your-remote-machine-with-wget"><a href="#Downloading-packages-to-your-remote-machine-with-wget" class="headerlink" title="Downloading packages to your remote machine with wget"></a>Downloading packages to your remote machine with wget</h3><p>Sometimes, you will need to download software packages from the internet to your VPS.  Since you do not have a GUI to work with, you must do this with the command line.  Let’s say I wanted to download a Google image to my VPS for whatever reason.</p>
<p>Here is a nice picture of a Husky - <a href="https://cdn.orvis.com/images/DBS_SibHusky.jpg" target="_blank" rel="noopener">https://cdn.orvis.com/images/DBS_SibHusky.jpg</a></p>
<p>We could download this to our VPS using the following command.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O my-custom-picture.jpg https://cdn.orvis.com/images/DBS_SibHusky.jpg</span><br></pre></td></tr></table></figure>
<p>This will download the photo and save it as <code>my-custom-picture.jpg</code> in whatever directory I execute the command from.</p>
<h3 id="Using-VSCode-with-your-remote-machine"><a href="#Using-VSCode-with-your-remote-machine" class="headerlink" title="Using VSCode with your remote machine"></a>Using VSCode with your remote machine</h3><p>Sure, you could use the Vim text editor for all of your development needs on a VPS, but it is nice to have a feature-rich text editor like VSCode.  We can use VSCode with files on our VPS with the help of the <code>rmate</code> command.  To do this, open VSCode, and download the extension called “Remote VSCode”.  Once downloaded, open your Settings by typing ctrl-shift + P, and typing “&gt;Preferences:Open User Settings”.  Scroll down and find the “Extensions” dropdown and select “Remote VSCode”.  In the settings, you will want the following: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Remote Host: 127.0.0.1</span><br><span class="line">Remote Port: 52698</span><br><span class="line">Remote Onstartup: True (will be a checkbox)</span><br></pre></td></tr></table></figure>
<p>Now, type ctrl-shift P again, and type “&gt;Remote: Start Server”.  This will start the Remote server.  Now, in your terminal, enter the following command to connect to your VPS.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -R 52698:127.0.0.1:52698 root@157.230.167.2</span><br></pre></td></tr></table></figure>
<p>Obviously, you will replace the IP address with your own.  Next, install the <code>rmate</code> utility on your VPS.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /usr/<span class="built_in">local</span>/bin/rmate https://raw.github.com/aurora/rmate/master/rmate</span><br><span class="line">sudo chmod a+x /usr/<span class="built_in">local</span>/bin/rmate</span><br></pre></td></tr></table></figure>
<p>You can now edit any file using VSCode by running the following command from your VPS!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmate sample-file.txt</span><br></pre></td></tr></table></figure>
<h2 id="Networking-on-Command-Line"><a href="#Networking-on-Command-Line" class="headerlink" title="Networking on Command Line"></a>Networking on Command Line</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/hGjF90P1Hr0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>Networking is a huge concept.  There are textbooks written on the topic, and therefore, I have no chance of covering everything you need to know relating to networking.  That said, this section will get into the most common Bash networking utilities that you can use to diagnose network issues on your computer.  If you are completely new to network concepts, that is completely fine as I will be explaining the basics of the internet in the next section.</p>
<h3 id="Your-home-network-and-the-internet"><a href="#Your-home-network-and-the-internet" class="headerlink" title="Your home network and the internet"></a>Your home network and the internet</h3><p>To make sense of the commands were are about to run, we need to have at least a foundational understanding of the following.</p>
<ol>
<li>Your Computer’s Wireless Card</li>
<li>Router</li>
<li>Modem</li>
<li>What your Internet Service Provider (ISP) is</li>
<li>Domain name system (DNS), nameservers, registrars</li>
</ol>
<p>Sometimes the modem and the router are one and the same, but for our purposes, we will be splitting them into two for a better conceptualization of the topic.  By the end of this section, <em>you will fully understand (at a high level) what happens when you type “<a href="http://www.thediygolfer.com&quot;" target="_blank" rel="noopener">www.thediygolfer.com&quot;</a> in your browser</em>.  I chose this particular website because I own it.  This will allow us to understand the components that go into it.  It is often difficult to explain these concepts with complex websites like <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> because their infrastructure is so complex.  The same concepts apply no matter what website you visit, but keeping things as simple as possible is key to understanding.</p>
<p><em>Note: I will be modifying some of the IP addresses and server addresses throughout the tutorial to protect my own privacy, but will not be changing them materially enough to affect the concepts explained herein.</em></p>
<p>We will start with a diagram to guide us through the process of searching for a website.</p>
<img src="/blog/2019/bash-essentials/basic-web-search.jpg">
<p>Each piece of the puzzle is labeled by number and illustrates the general flow of information when you make an internet search.  Although in most cases starting at #1 would make sense, we need to understand what an internet service provider (ISP) is and what service it provides.  ISPs are confusing in many cases because they offer more than one service, but in the scope of this post, let’s consider an ISP that offers only internet as a service.  An ISP is simply a company that owns hardware (wires) and makes that hardware available to customers in the form of internet service.  What are these wires we speak of?  Many ISPs own a variety of hardware that all are capable of carrying the analog signals we know as the “internet”.</p>
<ul>
<li>Coaxial cables (what you have in your house)</li>
<li>Unshielded twisted pair (UTP) cables (100 Mhz)</li>
<li>Shielded twisted pair (STP) cables</li>
<li>Fiber optic cables (fastest type - many are in the ocean)</li>
</ul>
<p>There are multiple ways that internet can reach your home, but the most common is through telephone wires (UTP cables).  Other methods include underground cables and dish satellites.  The method of telephone wires often confuses people because given the name, you would assume that only telephone signals can be sent through telephone wires.  This is not the case.  The internet bootstrapped off of the phone system, and nowadays, there are multiple channels of communication running through each telephone wire.  We call this “broadband” and it is the reason we can talk on the phone, watch Netflix, and search the web all at the same time.  Previously, you had to use “dial up” where you would literally “call in” through the phone line to access the internet.</p>
<p>Regardless the method your ISP uses to get internet to your home, you will always be faced with the same problem.  The signals traveling through the telephone wires your ISP owns are <em>analog</em> signals (wave frequencies), while your computer runs on <em>digital</em> signals (1s and 0s).  This is where the modem comes in.</p>
<p>The modem takes that analog signal, converts it to a digital signal, and sends it over to the router.  We do not yet understand what the router does, but you now have the background information needed to understand my picture diagram.  We know that our internet service provider owns tons of wires and infrastructure that millions of people connect to, and each ISP connects to each other.  This makes up the internet, and is ported into your home through telephone wires, underground cables, or satellite.  When it reaches your home, it is converted to digital signals by your modem and is sent to the router.  Our question now is what does the router do with the signal?</p>
<p>Well, this is a bit of a trick question, because we now must reverse the flow of information and start at the first link in the chain–your computer.  All that “internet connectivity” that your ISP is providing is useless unless you use it, so we first need to make an internet request to see it in action.  As mentioned, we are going to perform a basic search for the homepage of my website, <a href="http://www.thediygolfer.com" target="_blank" rel="noopener">www.thediygolfer.com</a>.</p>
<p>I open my computer, open my browser (in this case, Google Chrome), and type “<a href="http://www.thediygolfer.com&quot;" target="_blank" rel="noopener">www.thediygolfer.com&quot;</a> into the search bar.  I press Enter.  At this point, given only one piece of information, my browser application must embark on a journey across the world wide web to find this website.  Remember, a website is simply a bunch of files sitting on a server application that is running on some computer somewhere in the world.  In our case, the website we are searching for is located in New York somewhere, but our browser does not yet know this!</p>
<p>The first step my computer will take is forming a basic HTTP GET request.  It is not important to understand what this means, but understand that it is a structured way that a browser communicates.  Here is my GET request.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.thediygolfer.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.96 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: en-US,en;q=0.9</span><br></pre></td></tr></table></figure>
<p>I won’t explain every line here, but you can reasonably infer what each line means.  The one we will look at is the “Host: <a href="http://www.thediygolfer.com&quot;" target="_blank" rel="noopener">www.thediygolfer.com&quot;</a> line.  This information along with the rest is put into a “packet”, which is then sent to the router over the connection between the router and your computer’s wireless card.  Once it reaches the router, the router will act as a “sorting machine” and route the request where it needs to go.  The real question is… How does the router know where this request needs to go?</p>
<p>This is where the Domain Name System (DNS) comes in.  Across the world, there are thousands of servers that are running for a single purpose.  That purpose is to convert human readable domain names into IP addresses.  In other words, my router knows where to direct my request because it has access to a domain name server somewhere.  Every router will have a default DNS server that it uses.  My router uses the domain name server sitting at <code>208.67.222.123</code>.  If you type this IP address into a lookup site like <a href="https://whatismyipaddress.com/ip" target="_blank" rel="noopener">https://whatismyipaddress.com/ip</a>, you will find the following “DNS” information about it.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">IP:	208.67.222.123</span><br><span class="line">Decimal:	3494108795</span><br><span class="line">Hostname:	resolver1-fs.opendns.com</span><br><span class="line">ASN:	36692</span><br><span class="line">ISP:	OpenDNS, LLC</span><br><span class="line">Organization:	OpenDNS, LLC</span><br><span class="line">Services:	None detected</span><br><span class="line">Type:	Corporate</span><br><span class="line">Assignment:	Static IP</span><br><span class="line">Blacklist:	</span><br><span class="line">Continent:	North America</span><br><span class="line">Country:	United States us flag</span><br><span class="line">Latitude:	37.751  (37° 45′ 3.60″ N)</span><br><span class="line">Longitude:	-97.822  (97° 49′ 19.20″ W)</span><br></pre></td></tr></table></figure>
<p>Immediately we can see that this server is run by OpenDNS LLC, which makes sense because this is a well known DNS server.  Another well known DNS server is Google, which runs at the IP address 8.8.8.8.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">IP:	8.8.8.8</span><br><span class="line">Decimal:	134744072</span><br><span class="line">Hostname:	google-public-dns-a.google.com</span><br><span class="line">ASN:	15169</span><br><span class="line">ISP:	Google</span><br><span class="line">Organization:	Google</span><br><span class="line">Services:	None detected</span><br><span class="line">Type:	Corporate</span><br><span class="line">Assignment:	Static IP</span><br><span class="line">Blacklist:	</span><br><span class="line">Continent:	North America</span><br><span class="line">Country:	United States us flag</span><br><span class="line">Latitude:	37.751  (37° 45′ 3.60″ N)</span><br><span class="line">Longitude:	-97.822  (97° 49′ 19.20″ W)</span><br></pre></td></tr></table></figure>
<p>My router will contact its default DNS server, which will then search for the address “<a href="http://www.thediygolfer.com&quot;" target="_blank" rel="noopener">www.thediygolfer.com&quot;</a>.  Assuming it does not find it right away in its cache, it will start at the root domain database for the <code>.com</code> top-level-domain, which is hosted by the company VeriSign.  I know this because <a href="https://www.iana.org/domains/root/db/com.html" target="_blank" rel="noopener">I looked it up on IANA.org</a>.  This root database will know where <code>thediygolfer.com</code> is because I registered it with an official registrar called <a href="https://www.namesilo.com/register.php?rid=21c9e40dd" target="_blank" rel="noopener">NameSilo</a>.  When I registered it, the domain was placed in the <code>.com</code> top-level-domain database hosted by Verisign.  I then told NameSilo where I want to point the domain name to.  Since my site is hosted on DigitalOcean, I told NameSilo to point <code>thediygolfer.com</code> to DigitalOcean’s DNS servers, which are:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">173.245.58.51</span><br><span class="line">173.245.59.41</span><br><span class="line">198.41.222.173</span><br></pre></td></tr></table></figure>
<p>Any of these three servers will know what IP address <code>thediygolfer.com</code> maps to.  At this point, my router has started with the default OpenDNS server to look for <code>thediygolfer.com</code>, but failing to find it, OpenDNS redirected the router to the root domain database, which then found the domain and redirected the router to Digital Ocean nameservers, which know exactly where the physical machine that my site is running on is.  The router will now figure out the quickest path to this location and send off the request packet.</p>
<p>On the other end, the server which is running my website will find the HTML document that was requested (the home page), package it up, and send it back to the requesting IP address (my computer).  The packets will be delivered to my router, but how does my router know where my computer is?  This brings us to the topic of local area networks, or LANs.  </p>
<p>The router represents a “local network”, and actually has a dynamic IP address (DHCP) that will change from time to time.  This is okay because my request I sent has the current IP address for my home network and therefore the server sending back the information will find my network.  Once it finds the network, the router is in charge of routing that information to the correct device in my local network.</p>
<p>A home has multiple devices (laptop, desktop, Chromecast, printer, etc.), and therefore each home network will need multiple IP addresses.  It would be difficult to manage a new IP address for each device out in the wild, but with our local area network, it is simple.  The network itself has an IP address which is called the “default gateway”.  This IP address represents all the devices on the network and is where traffic leaves and enters.  Within the local network, each device has a “subnet mask” which will create a unique IP address for each device within the bounds of the local area network address space.  This topic is impossible to understand without an understanding of subnetting, so <a href="/blog/2019/ip-addresses-netmasks">I have written a separate post</a> to explain it for anyone looking to more deeply understand what is going on.  If you choose not to read it, here are the cliffnotes (and a diagram):</p>
<img src="/blog/2019/bash-essentials/ipaddresses.PNG">
<ul>
<li>Your ISP assigns your network an IP address and a subnet mask.  Adding the two together gives you the “network” or “default gateway” address.  In other words, an IP address is made of two parts–the network identifier and the host “address space” identifier.</li>
<li>The reason we have subnet masks is to conserve the address space used by a single network.  An address space is the range of IP addresses available for devices in a network (i.e. 192.0.168.1, 192.0.168.2, 192.0.168.3, 192.0.168.4, …, 192.0.168.254)</li>
<li>DHCP is a server (usually running on a router) that assigns a new device an IP address when it enters a network.  This IP will always be within the address space as defined by the subnet mask.</li>
</ul>
<p>Anyways, back to our discussion… We have a bunch of data packets coming from the website server and being delivered to our router.  The device you searched from is found by the router, the website data is delivered, and we see the homepage of <a href="http://www.thediygolfer.com" target="_blank" rel="noopener">www.thediygolfer.com</a>.  Although a complex process, it all happens in seconds (or even milliseconds).  With this background knowledge, we can now look at some bash commands to help us diagnose network issues.</p>
<h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>The ifconfig command will give us the information that we just discussed about our LAN (local area network).  This command can also be used to set new configurations, but for our use, we will just look at the output.  Type <code>ifconfig</code> in your terminal, and you should get the following output.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">enp37s0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether 70:85:c2:7c:ff:f2  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">enx000f00de66da: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet &lt;hidden for privacy&gt;  netmask 255.255.255.0  broadcast &lt;hidden for privacy&gt;</span><br><span class="line">        inet6 &lt;hidden for privacy&gt;  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0f:00:de:66:da  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 265073  bytes 821138812 (821.1 MB)</span><br><span class="line">        RX errors 0  dropped 1451  overruns 0  frame 0</span><br><span class="line">        TX packets 44132  bytes 102041651 (102.0 MB)</span><br><span class="line">        TX errors 0  dropped 2100 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 752935  bytes 54372769 (54.3 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 752935  bytes 54372769 (54.3 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
<p>There are three entries in my configuration.  The bottom one called “lo” is a loopback configuration which redirects the address 127.0.0.1 to “localhost”, and is commonly used for developing web applications.  The first entry “enp37s0” seems to be an empty configuration.  The middle entry “enx000f00de66da” is what we are interested in, because it displays the IP address of this device, the subnet mask, and the broadcast address of my LAN.  </p>
<p>This is where an <a href="/blog/2019/ip-addresses-netmasks">understanding of IP addresses and subnetting on a LAN</a> is helpful, because the INET address listed is not actually the public IP address recognized by the broader internet.  This IP address is the <em>local</em> identifier which can be translated into the public IP for the network by combining it with the subnet mask which is also listed.  The broadcast address is also listed, but we could easily have derived that from the IP address and the subnet mask as well.</p>
<p>If I typed ifconfig into another computer on my network, the broadcast address and subnet mask will not change, but the IP address will.  There is also data like the maximum transmission units (MTU) which is the maximum size of a packet on this device, and RX/TX packets which indicate how many packets have been transmitted to and from this network.  These values will be constantly increasing.</p>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>The <code>ping</code> command is a basic utility you can use to check connectivity between devices on your LAN or even between devices outside your LAN.  This command is useful in cases where you do not have a browser to test internet connectivity.  There are configuration options for the command, but the only one that you need to know is the <code>-c</code> option, which will allow you to specify the number of packets to request from a given source.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 5 thediygolfer.com</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PING thediygolfer.com (104.248.115.234) 56(84) bytes of data.</span><br><span class="line">64 bytes from 104.248.115.234 (104.248.115.234): icmp_seq=1 ttl=48 time=36.0 ms</span><br><span class="line">64 bytes from 104.248.115.234 (104.248.115.234): icmp_seq=2 ttl=48 time=49.9 ms</span><br><span class="line">64 bytes from 104.248.115.234 (104.248.115.234): icmp_seq=3 ttl=48 time=35.2 ms</span><br><span class="line">64 bytes from 104.248.115.234 (104.248.115.234): icmp_seq=4 ttl=48 time=34.4 ms</span><br><span class="line">64 bytes from 104.248.115.234 (104.248.115.234): icmp_seq=5 ttl=48 time=35.3 ms</span><br><span class="line"></span><br><span class="line">--- thediygolfer.com ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 4005ms</span><br><span class="line">rtt min/avg/max/mdev = 34.427/38.183/49.912/5.885 ms</span><br></pre></td></tr></table></figure>
<p>The command above sends my site’s homepage 5 separate requests, and we receive data about each request.  Based on the data, we know our computer is online and able to connect to thediygolfer.com.</p>
<h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><p>The traceroute command is a great way to understand how your computer locates and routes your request to <a href="http://www.thediygolfer.com" target="_blank" rel="noopener">www.thediygolfer.com</a>.  I had mentioned earlier that the server for my site is somewhere in New York, and the traceroute command will validate that by showing you the path we take to get there.</p>
<p>This command may not be installed by default on your machine, so if it is not available, you will need to install it.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linux</span></span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt install inetutils-traceroute</span><br></pre></td></tr></table></figure>
<p>On Mac, you can access this with the Network Utility.  When we run traceroute, we get the following output.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute --resolve-hostnames -q 1 -w 5 -I thediygolfer.com</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">traceroute to thediygolfer.com (104.248.115.234), 64 hops max</span><br><span class="line">  1   192.168.0.1 (_gateway)  53.296ms </span><br><span class="line">  2   142.254.145.21 (142.254.145.21)  10.502ms </span><br><span class="line">  3   24.164.117.37 (24.164.117.37)  15.953ms </span><br><span class="line">  4   65.189.128.164 (65.189.128.164)  11.035ms </span><br><span class="line">  5   65.29.1.87 (be14.pltsohae01r.midwest.rr.com)  18.102ms </span><br><span class="line">  6   65.29.1.28 (be25.clmkohpe01r.midwest.rr.com)  23.729ms </span><br><span class="line">  7   66.109.6.68 (bu-ether15.chctilwc00w-bcr00.tbone.rr.com)  31.967ms </span><br><span class="line">  8   66.109.5.136 (66.109.5.136)  34.155ms </span><br><span class="line">  9   66.109.5.225 (66.109.5.225)  26.993ms </span><br><span class="line"> 10   64.86.79.97 (ix-ae-27-0.tcore2.ct8-chicago.as6453.net)  25.094ms </span><br><span class="line"> 11   64.86.79.2 (if-ae-22-2.tcore1.ct8-chicago.as6453.net)  33.455ms </span><br><span class="line"> 12   216.6.81.28 (if-ae-26-2.tcore2.nto-new-york.as6453.net)  35.629ms </span><br><span class="line"> 13   66.110.96.5 (if-ae-12-2.tcore1.n75-new-york.as6453.net)  33.047ms </span><br><span class="line"> 14   66.110.96.26 (66.110.96.26)  34.565ms </span><br><span class="line"> 15   * </span><br><span class="line"> 16   * </span><br><span class="line"> 17   104.248.115.234 (104.248.115.234)  35.916ms</span><br></pre></td></tr></table></figure>
<p> In the command above, I have indicated to the traceroute utility that I want to resolve IP addresses into their hostnames with the <code>--resolve-hostnames</code> command, I want to send only one packet per host <code>-q 1</code>, I want to set the timeout for each request to 5 seconds with <code>-w 5</code>, and finally, I want to use ICMP protocol rather than UDP with the <code>-I</code> flag.  As you can see, the request starts at my computer’s gateway, jumps over to a Spectrum server in Kansas, connects to a server in Chicago, connects to Digital Ocean’s servers in New York, and finally gets to my website server in New Jersey.  I know the locations because I typed a few of them into <a href="https://whatismyipaddress.com/ip-lookup" target="_blank" rel="noopener">this online tool</a>.   </p>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>This command gives information about the various networking protocols (TCP/IP, UDP, ICMP, etc.) that your machine is using.  Most of what this tool prints is out of the scope of what we discussed above, but I’ll mention it nevertheless because it is a crucial tool for understanding how your computer is communicating with the outside world.  For example, we can type the following command to see the activity that is happening on various networking protocols.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s</span><br></pre></td></tr></table></figure>
<p>The output of this is below.  Please note that the output has been trimmed for brevity and only the IP, TCP, and UDP protocols have been included.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Ip:</span><br><span class="line">    400933 total packets received</span><br><span class="line">    0 forwarded</span><br><span class="line">    0 incoming packets discarded</span><br><span class="line">    400933 incoming packets delivered</span><br><span class="line">    296285 requests sent out</span><br><span class="line">    3 outgoing packets dropped</span><br><span class="line">Tcp:</span><br><span class="line">    32175 active connections openings</span><br><span class="line">    28 passive connection openings</span><br><span class="line">    0 failed connection attempts</span><br><span class="line">    4 connection resets received</span><br><span class="line">    1 connections established</span><br><span class="line">    400885 segments received</span><br><span class="line">    300195 segments send out</span><br><span class="line">    41 segments retransmited</span><br><span class="line">    0 bad segments received.</span><br><span class="line">    7 resets sent</span><br><span class="line">Udp:</span><br><span class="line">    28 packets received</span><br><span class="line">    0 packets to unknown port received.</span><br><span class="line">    0 packet receive errors</span><br><span class="line">    43 packets sent</span><br></pre></td></tr></table></figure>
<p>Another useful application of the netstat utility is to see what processes on your computer are using what ports.  We have not discussed processes yet, but keep this in mind for later.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tp</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 zubuntu:35098           stackoverflow.com:https ESTABLISHED 26679/chrome --type</span><br></pre></td></tr></table></figure>
<p>I have cut off most of the output of this command, but with the single example that I did provide, you can see that I have a Google Chrome window open (with process ID 26679) and one of my tabs is opened to stackoverflow.com.  The local address means that my local host (zubuntu - the fully qualified name for 127.0.0.1) has a socket with ID 35098 open for the given tab in my Google Chrome window.  Each tab will have its own socket.</p>
<h3 id="dig-host-whois"><a href="#dig-host-whois" class="headerlink" title="dig/host/whois"></a>dig/host/whois</h3><p>The <code>dig</code>, <code>host</code>, and <code>whois</code> utilities help find information about domain names, IP addresses, and the mapping between them.  <code>dig</code> and <code>host</code> should be installed on your machine already, but you may have to install the <code>whois</code> utility to use it.  On linux, you can install it by typing <code>sudo apt-get install whois</code> in your terminal.</p>
<p>We will start with the <code>dig</code> utility which helps us query DNS records for either IP addresses (using a reverse lookup) or a domain name.  Using this utility, we can query my site.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig thediygolfer.com</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.5-3ubuntu0.15-Ubuntu &lt;&lt;&gt;&gt; thediygolfer.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 51716</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;thediygolfer.com.              IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">thediygolfer.com.       600     IN      A       104.248.115.234</span><br><span class="line"></span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 172.17.0.1#53(172.17.0.1)</span><br><span class="line">;; WHEN: Wed Feb 27 18:41:22 UTC 2019</span><br><span class="line">;; MSG SIZE  rcvd: 61</span><br></pre></td></tr></table></figure>
<p>Notice there is a lot of information here, and most of it is comments (indicated by ;;).  To reduce the output that we see, we can add the <code>+noall</code> flag and <code>+answer</code> flag to reduce all output and only see the answer section. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig thediygolfer.com +noall +answer</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.5-3ubuntu0.15-Ubuntu &lt;&lt;&gt;&gt; thediygolfer.com +noall +answer</span><br><span class="line">;; global options: +cmd</span><br><span class="line">thediygolfer.com.       600     IN      A       104.248.115.234</span><br></pre></td></tr></table></figure>
<p>This will just print the A record for my site in a short format.  We could have also run <code>dig thediygolfer.com +short</code> to get a similar output.  But what if we wanted all the DNS records for a domain?  To do this, we can add the <code>ANY</code> option.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig thediygolfer.com ANY +noall +answer</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.5-3ubuntu0.15-Ubuntu &lt;&lt;&gt;&gt; thediygolfer.com ANY +noall +answer</span><br><span class="line">;; global options: +cmd</span><br><span class="line">thediygolfer.com.       3599    IN      A       104.248.115.234</span><br><span class="line">thediygolfer.com.       1799    IN      NS      ns1.digitalocean.com.</span><br><span class="line">thediygolfer.com.       1799    IN      NS      ns2.digitalocean.com.</span><br><span class="line">thediygolfer.com.       1799    IN      NS      ns3.digitalocean.com.</span><br><span class="line">thediygolfer.com.       1799    IN      SOA     ns1.digitalocean.com. hostmaster.thediygolfer.com. 1545305910 10800 3600 604800 1800</span><br></pre></td></tr></table></figure>
<p>In this response, you can see that I have one A record (the mapping between IP and domain name), three nameserver records, and one “Start of Authority” (SOA) record that indicates Digital Ocean is the authoritative source for the DNS record.</p>
<p>We can also type the following command to find the IP address for a given domain.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">host thediygolfer.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># thediygolfer.com has address 104.248.115.234</span></span><br></pre></td></tr></table></figure>
<p>If you use this command with a larger company like Google, you will get more verbose results due to the fact that they operate many servers and many mail servers.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host google.com</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">google.com has address 108.177.112.139</span><br><span class="line">google.com has address 108.177.112.101</span><br><span class="line">google.com has address 108.177.112.102</span><br><span class="line">google.com has address 108.177.112.100</span><br><span class="line">google.com has address 108.177.112.113</span><br><span class="line">google.com has address 108.177.112.138</span><br><span class="line">google.com has IPv6 address 2607:f8b0:4001:c12::64</span><br><span class="line">google.com mail is handled by 30 alt2.aspmx.l.google.com.</span><br><span class="line">google.com mail is handled by 50 alt4.aspmx.l.google.com.</span><br><span class="line">google.com mail is handled by 40 alt3.aspmx.l.google.com.</span><br><span class="line">google.com mail is handled by 10 aspmx.l.google.com.</span><br><span class="line">google.com mail is handled by 20 alt1.aspmx.l.google.com.</span><br></pre></td></tr></table></figure>
<p>Finally, we can use the <code>whois</code> command to find more information about a given domain name or IP address.  You may not have this installed by default, so you can type <code>sudo apt-get install whois</code> to install it.  Here is an example of how it works.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whois thediygolfer</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Domain Name: THEDIYGOLFER.COM</span><br><span class="line">Registry Domain ID: 1896554473_DOMAIN_COM-VRSN</span><br><span class="line">Registrar WHOIS Server: whois.namesilo.com</span><br><span class="line">Registrar URL: http://www.namesilo.com</span><br><span class="line">Updated Date: 2018-12-15T15:30:57Z</span><br><span class="line">Creation Date: 2015-01-18T02:22:03Z</span><br><span class="line">Registry Expiry Date: 2020-01-18T02:22:03Z</span><br><span class="line">Registrar: NameSilo, LLC</span><br><span class="line">Registrar IANA ID: 1479</span><br><span class="line">Registrar Abuse Contact Email: abuse@namesilo.com</span><br><span class="line">Registrar Abuse Contact Phone: +1.4805240066</span><br><span class="line">Domain Status: clientTransferProhibited https://icann.org/epp#clientTransferProhibited</span><br><span class="line">Name Server: NS1.DIGITALOCEAN.COM</span><br><span class="line">Name Server: NS2.DIGITALOCEAN.COM</span><br><span class="line">Name Server: NS3.DIGITALOCEAN.COM</span><br><span class="line">DNSSEC: unsigned</span><br><span class="line">URL of the ICANN Whois Inaccuracy Complaint Form: https://www.icann.org/wicf/</span><br></pre></td></tr></table></figure>
<p>You can see the public information about a given domain.</p>
<p>There are other bash tools like <code>nslookup</code>, <code>route</code>, etc., but the ones I have reviewed will take care of most user needs.  Unless you are an admin configuring networks on a daily basis, you will never need to use these tools to edit settings.  These commands are useful for quick info relating to your network and external networks.</p>
<h2 id="Process-Management-and-System-Management"><a href="#Process-Management-and-System-Management" class="headerlink" title="Process Management and System Management"></a>Process Management and System Management</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/lfN2RE8720E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>Process and system management sounds like an intimidating concept, but for the average bash user, there are only a few commands and programs that you will need to learn to get a holistic understanding of how your computer runs.</p>
<ul>
<li>What is a process?</li>
<li>How is a process created?</li>
<li>How to manage processes with kill, bg, and fg commands</li>
<li>How to manage processes and monitor system resources with top command</li>
</ul>
<h3 id="What-is-a-Process"><a href="#What-is-a-Process" class="headerlink" title="What is a Process?"></a>What is a Process?</h3><p>Without getting super technical, a process is anything on your computer that is owned by a single user and that consumes one of three system resources.</p>
<ol>
<li>CPU</li>
<li>Memory</li>
<li>I/O (input/output)</li>
</ol>
<p>While your computer is on and running, the kernel is constantly working.  The kernel is constantly monitoring all the processes on your computer and allocating one or more of the three system resources to them in intervals.  All the processes are constantly fighting for the resources and will take turns using them.  Believe it or not, when you run a program like Google Chrome, the kernel will give it resources for a few seconds and then do a “context switch” where it hands those same resources off to another process for a few seconds.  If Google Chrome got 100% of the computer’s resources 100% of the time, the computer would become dysfunctional because there are many processes that are running at the kernel level to keep everything in order.</p>
<h3 id="Processes-Behind-the-Scenes"><a href="#Processes-Behind-the-Scenes" class="headerlink" title="Processes Behind the Scenes"></a>Processes Behind the Scenes</h3><p>I could list out a bunch of commands here for you, but they will not make any sense unless you understand the sequence that the bash shell (and kernel) takes when a new process is started.  When your computer starts up, the kernel will call a process called “init”, which on a UNIX-based operating system is usually the script called <code>init</code> located at <code>/sbin/init</code>.  This is the <a href="https://en.wikipedia.org/wiki/Systemd" target="_blank" rel="noopener">systemd</a> init script.  This does not make a lot of sense starting out, but once you know how a process starts, you will gain clarity into what goes on behind the scenes on your computer.  A process can start another process (usually the terminal starting a new process as a result of a command typed into it) by first creating a copy of itself, and then executing the new command within that copied process.  Here is a visual to better explain: </p>
<img src="/blog/2019/bash-essentials/processes-linux.png">
<p>We can also simulate this process in a terminal ourselves using the <code>strace()</code> command.  Please note this command is only available on Linux.  The equivalent command on Mac is the <code>dtruss</code> command, but it does not work exactly the same.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace ls</span><br></pre></td></tr></table></figure>
<p>When you run this command, you will see all of the system calls that were made when you ran the <code>ls</code> command.  Although <code>ls</code> is considered a “command” in many people’s minds, it is really just another process.  I have cut out parts of the <code>strace ls</code> output below and highlighted some of the most important parts.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;/bin/ls&quot;, [&quot;ls&quot;], [/* 69 vars */]) = 0</span><br><span class="line"></span><br><span class="line">.... omitted for brevity ....</span><br><span class="line"></span><br><span class="line">write(1, &quot;_config.yml  awk-example.sh  db.&quot;..., 107_config.yml  awk-example.sh  db.json      node_modules    package.json  scaffolds  test-permission  yarn.lock</span><br><span class="line">) = 107</span><br><span class="line">write(1, &quot;aapl.csv     data-file.txt   lar&quot;..., 91aapl.csv     data-file.txt   large-data.csv  package-lock.json public       source    themes</span><br><span class="line">) = 91</span><br><span class="line">close(1)                                = 0</span><br><span class="line">munmap(0x7f1578100000, 4096)            = 0</span><br><span class="line">close(2)                                = 0</span><br><span class="line">exit_group(0)                           = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure>
<p>If you are truly curious about each of the system calls in the <code>strace</code> command output, <a href="https://stackoverflow.com/a/6334557" target="_blank" rel="noopener">here is a great StackOverflow post</a>.  If you have ever programmed in the C programming language, you might find a few of these commands familiar.  </p>
<p>In the output that I have shown, you can see the <code>execve</code> command starts off the process.  This actually does the fork and exec all in one.  Later in the command, you will see file and directory names.  These represent the output of the ls command that you would see if you just ran <code>ls</code> in the current directory of my machine.  </p>
<p>In the end, the output is not important to you as a bash user, but is important in trying to understand how the computer starts and ends processes.  What we care more about is how to <em>manage</em> processes.  There are only a few commands that we need to look at here because these few commands will take care of essentially anything we would ever need to do relating to processes.</p>
<h3 id="Foreground-vs-Background-Processes"><a href="#Foreground-vs-Background-Processes" class="headerlink" title="Foreground vs. Background Processes"></a>Foreground vs. Background Processes</h3><p>One of the most important concepts to understand regarding processes is the background vs. the foreground process and how to switch between the two.  When you run a process in your bash shell, while that process is running, you will not have access to the terminal.  If you want to stop that process, you can always hit the CTRL-C command.  But there are multiple processes that are running at any given time, so where are they running?  Why don’t they prevent you from working in the terminal?  The reason is because they are <em>background processes</em>.  We can send a process to the background in one of two ways:</p>
<ol>
<li>Send it to the background at start time</li>
<li>Stop it, send it to the background, and start it again</li>
</ol>
<p>The first method is simple.  We can start a process in the background by adding the <code>&amp;</code> character at the end of the command.  For example, I can run the <code>sleep</code> command for 20 seconds in the background.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep 20 &amp;</span><br></pre></td></tr></table></figure>
<p>The second method is a bit more complicated and requires us to understand the concept of <em>process signals</em>.  We can send process signals using the <code>kill</code> command.  You can see all the signals by typing <code>kill -l</code>, but here are the most common signals that you might send to a process:</p>
<ul>
<li>SIGTERM - <code>kill</code> (gracefully sends shutdown signal to process)</li>
<li>SIGKILL - <code>kill -9</code> or <code>kill -s SIGKILL</code> (brute force shutdown)</li>
<li>SIGSTOP - <code>kill -19</code> or <code>kill -s SIGSTOP</code> (stops running process)</li>
<li>SIGCONT - <code>kill -18</code> or <code>kill -s SIGCONT</code> (continues stopped process)</li>
<li>SIGINT (CTRL-C) - <code>kill -2</code> or <code>kill -s SIGINT</code> (interrupt process)</li>
<li>SIGTSTP (CTRL-Z) - <code>kill -20</code> or <code>kill -s SIGTSTP</code> (stops the running process)</li>
</ul>
<p>In our case, we want to send the SIGTSTP signal to our running process to throw it in the background and stop it.  We will need the process ID to do this.  To get that process ID, we can run the <code>ps</code> command (more on this later).  In my case, I am running the <code>google-chrome</code> command (will launch a Google Chrome Window) as a sample process that we can work with, and its process ID is 21124 as shown in the <code>ps a</code> output below.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line"> 1201 tty7     Ssl+   1:48 /usr/lib/xorg/Xorg -core :0 -seat seat0 -auth /var/run/lightdm/root/:0 -nolis</span><br><span class="line"> 1204 tty1     Ss+    0:00 /sbin/agetty -o -p -- \u --noclear tty1 linux</span><br><span class="line">17824 pts/0    Ss     0:00 -bash</span><br><span class="line">18747 pts/1    Ss+    0:00 /bin/bash</span><br><span class="line">19664 pts/2    Ss+    0:00 -bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># This is the Google Chrome Process (this comment was manually added to ps output)</span></span><br><span class="line">21124 pts/2    SLl    0:03 /opt/google/chrome/chrome</span><br><span class="line"></span><br><span class="line">21129 pts/2    S      0:00 cat</span><br><span class="line">21130 pts/2    S      0:00 cat</span><br><span class="line">21133 pts/2    S      0:00 /opt/google/chrome/chrome --<span class="built_in">type</span>=zygote --<span class="built_in">enable</span>-crash-reporter=2475ab0f-df4d</span><br><span class="line">21134 pts/2    S      0:00 /opt/google/chrome/nacl_helper</span><br><span class="line">21137 pts/2    S      0:00 /opt/google/chrome/chrome --<span class="built_in">type</span>=zygote --<span class="built_in">enable</span>-crash-reporter=2475ab0f-df4d</span><br><span class="line">21164 pts/2    Sl     0:00 /opt/google/chrome/chrome --<span class="built_in">type</span>=gpu-process --field-trial-handle=39017447716</span><br><span class="line">21169 pts/2    SLl    0:00 /opt/google/chrome/chrome --<span class="built_in">type</span>=utility --field-trial-handle=390174477165224</span><br><span class="line">21309 pts/2    Sl     0:00 /opt/google/chrome/chrome --<span class="built_in">type</span>=renderer --field-trial-handle=39017447716522</span><br><span class="line">21360 pts/2    Sl     0:01 /opt/google/chrome/chrome --<span class="built_in">type</span>=renderer --field-trial-handle=39017447716522</span><br><span class="line">21398 pts/2    Sl     0:00 /opt/google/chrome/chrome --<span class="built_in">type</span>=renderer --field-trial-handle=39017447716522</span><br><span class="line">21417 pts/2    Sl     0:00 /opt/google/chrome/chrome --<span class="built_in">type</span>=renderer --field-trial-handle=39017447716522</span><br><span class="line">21711 pts/2    Sl     0:01 /opt/google/chrome/chrome --<span class="built_in">type</span>=renderer --field-trial-handle=39017447716522</span><br><span class="line">21751 pts/2    Sl     0:00 /opt/google/chrome/chrome --<span class="built_in">type</span>=renderer --field-trial-handle=39017447716522</span><br><span class="line">21852 pts/2    Sl     0:00 /opt/google/chrome/chrome --<span class="built_in">type</span>=renderer --field-trial-handle=39017447716522</span><br><span class="line">21870 pts/0    R+     0:00 ps a</span><br></pre></td></tr></table></figure>
<p>I actually have several options here to stop the running Google Chrome process.  I could send the <code>SIGTSTP</code> signal (i.e. CTRL-Z), or I could send the <code>SIGSTOP</code> process signal to the process.  Either of these will stop the running process and give us our terminal back.  I am going to send the <code>SIGSTOP</code> process from a separate terminal window.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -s SIGSTOP 21124</span><br><span class="line"><span class="comment"># `kill -19 21124` also works</span></span><br></pre></td></tr></table></figure>
<p>You will notice that when you try to do anything in the Chrome window, it will not work because it is a stopped process.  We can now start the process again but this time, we will throw it in the background.  To do this, go to the terminal where Google Chrome has stopped and type the command <code>jobs</code>.  This will give you that terminal’s list of jobs.  We want to find the number that Google Chrome is identified by (in my case it is job #1) and run the following command.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bg</span> %1</span><br></pre></td></tr></table></figure>
<p>Google Chrome is now started again and in the background.  Let’s now stop it again, start it again, and then bring it back to the foreground.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Stops process</span></span><br><span class="line"><span class="built_in">kill</span> -s SIGSTOP 211124</span><br><span class="line"></span><br><span class="line"><span class="comment"># Starts process</span></span><br><span class="line"><span class="built_in">kill</span> -s SIGCONT 211124</span><br><span class="line"></span><br><span class="line"><span class="comment"># Brings process to foreground</span></span><br><span class="line"><span class="built_in">fg</span> %1</span><br></pre></td></tr></table></figure>
<h3 id="ps-and-top-commands-system-performance-management"><a href="#ps-and-top-commands-system-performance-management" class="headerlink" title="ps and top commands (system performance management)"></a>ps and top commands (system performance management)</h3><p>There are two commands that give us output relating to the processes that are currently running on our computer.  In 99% of the cases, these commands can be run interchangeably for the same type of data.  The difference between the commands is the level of interactivity and therefore the situations you would be likely to use them both in.  For example, when you run the <code>top</code> command, you will see a bunch of processes listed out.  Not only will this command list processes, but it will also update the status of each process in real time.  Since it is interactive, other scripts cannot use it to get information about processes without special configurations (i.e. using “batch” mode).  That is where the <code>ps</code> command enters the picture.  This command can be run inside bash scripts to obtain necessary information.  Since we are not looking to write complex process utilization scripts, we will be primarily focusing on the <code>top</code> command because it is more user-friendly.  If you want, you can read the man pages for the <code>ps</code> command to learn the equivalent commands that we talk about (hint: <code>ps ax</code> will print out all your current processes).</p>
<p>Our first priority is to learn the interface of the <code>top</code> command and what we need to look for in the output.  This is not just a bash command but an entire program that has extensive capabilities.  As a normal bash user you will not use most of the capabilities, but we will look at some useful and common ones.</p>
<img src="/blog/2019/bash-essentials/top-header.png">
<p>When first starting the top program, you will see the above output in the header.  There will be 5 lines here, and starting from the top line (1) going to the bottom line (5), let’s get a better idea of what this means.</p>
<ol>
<li>Not all that useful to us–just general info</li>
<li>Gives a breakout of the different types of tasks running on your computer.  These can be running, stopped, sleeping, or zombie.  These states are intuitive, except a zombie process, which is just a process that is killed but still showing up in the process table (usually because the parent process has failed to clean it up).</li>
<li>CPU time statistics including us (user time un-niced), sy (system time), ni (user time niced), id (idle time), and wa (I/O wait time).  The hi, si, and st are not important to us.  We can find the total user time (time it takes to run the actual code of a program) by adding us + ni.  This line will be more helpful to us when we are filtered by a specific process later.</li>
<li>Actual memory statistics.  If you are displaying all your processes and your free memory is low, this could be a red flag that you are running out of RAM.</li>
<li>Swap memory statistics.  Swap memory is only used when real memory is exhausted, so if you start seeing low numbers in the “free” part of <em>real memory</em> and high numbers in the “used” part of <em>swap memory</em>, there could be a performance issue on your computer caused by too little RAM.</li>
</ol>
<p>Moving down to the actual output of the top command, you may notice that it updates every few seconds.  This is useful because we get to see our computer in real time.  That said, it would be nice if we could control the interval length.  We can do this in one of two ways, which is a good introduction to the topic of “interactive” mode vs. “static” mode.  In static mode, we set configuration of the top program on the command line.  For example, we might open the top program like so: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -d 10</span><br></pre></td></tr></table></figure>
<p>This will open the top program and set the interval to 10 seconds.  We could also adjust this value by typing the letter <code>d</code> within the top program, and entering the number of seconds for the interval.  How did I know this?  For one, I read the man pages for the top command, but another way to find this info is by typing the <code>?</code> within the top program.  This will drop you into a help page that gives you hints on how to use the program.  From here you will only get information about the “interactive” mode, but generally, this is all you will ever need.  Unlike the <code>ps</code> command, we will never need to re-type the <code>top</code> command because all our configurations can be done within the program itself.</p>
<p>The top command is great because it acts as a process management tool and system management tool all in one.  Continuing our discussion on process management, we can kill processes within the top program.  Just type the letter <code>k</code> followed by the process ID.  This will send the default <code>SIGINT</code> kill signal to the process.  This does not have any customization (i.e. you cannot send a custom signal), but is a quick way to kill a process without breaking out of top.</p>
<p>We can also filter the top program by process ID, or even user ID.  Both of these can be set at the command line when starting the program.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Only displays the user "zach"'s processes</span></span><br><span class="line">top -u zach</span><br><span class="line"></span><br><span class="line"><span class="comment"># Only displays the process 22435</span></span><br><span class="line">top -p 22435</span><br></pre></td></tr></table></figure>
<p>We can also do these commands interactively within the top program.  If we wanted to only show the user <code>zach</code> processes, we type the letter <code>n</code> followed by “zach”.  If we wanted to display only process ID <code>22435</code>, we could put a filter on the top output.  We do this like so: </p>
<ol>
<li>Type the letter <code>O</code> (uppercase) in interactive mode</li>
<li>Type <code>PID=22435</code> and press Enter</li>
<li>Check your filters by typing CTRL-o (control + the letter o)</li>
<li>Clear your filters by typing <code>=</code></li>
</ol>
<p>By default, top gives quite a bit of output, and oftentimes, we will need to scroll through it.  You can scroll through the top output using the up, down, left, and right keys.  To see what coordinates you are at in the output, just type <code>C</code>.  This will give you an output at the top of your screen that says something like <code>scroll coordinates: y = 13/345 (tasks), x = 1/12 (fields)</code>.</p>
<p>We can also change what fields are displayed by typing the letter <code>f</code> in interactive mode.  When you type this, you will see a bunch of different field options.  Before we go into how we can organize our fields, we need to walk through the default fields and what they mean.</p>
<ol>
<li>PID - process ID</li>
<li>USER - user ID that owns the process</li>
<li>PR - The priority of the process (<code>rt</code> means the priority is set in real time)</li>
<li>NI - The “Nice” value of the process.  This is the user space version of priority and is directly related to priority (PR) by the following formula: PR = 20 + NI.  For both, the lower the number, the higher the priority.  See <a href="https://askubuntu.com/a/656787/917201" target="_blank" rel="noopener">this post</a> for a more detailed explanation.</li>
<li>VIRT - All virtual memory used for the process</li>
<li>RES - subset of VIRT</li>
<li>SHR - subset of RES</li>
<li>S - state (S for sleep, R for running, I for idle)</li>
<li>%CPU - The task’s share of elapsed CPU time since last screen update.  So if it is 50% and your interval time is 10 seconds, this means that over the last 10 seconds, this process has taken up 50% of all available CPU time.</li>
<li>%MEM - The same thing as RES, but expressed as a percentage</li>
<li>TIME+ - The total time the process has used since start time (assuming cumulative mode is on - toggle it with <code>S</code>)</li>
<li>COMMAND - The command that started the program.  Type <code>c</code> to toggle between the full name and abbreviated name.</li>
</ol>
<p>Unless you are a system management wizard, some of these default fields are not going to be that useful to you.  To change what fields are displayed, you can type <code>f</code> to enter the field manager.  When in the field manager, use you up and down arrow keys to highlight a specific field.  If the field has a <code>*</code> by it, this means that it is currently showing.  You can toggle this on and off using the letter <code>d</code>.  To move commands to a different location in the menu, highlight one, press the right arrow key to highlight the entire field, and then press up and down arrow keys until you have placed it where you want it.  Finally, press the left arrow key or Enter to place the menu item.  You can also change the field which top sorts by highlighting the field and typing the letter <code>s</code>.  Press <code>q</code> to quit.  Once you have set your favorite configuration, exit out of the field manager and type <code>W</code> to save your settings to the <code>~/.toprc</code> file.</p>
<p>If you want to display multiple windows in top (usually I do not need this feature), you can enter alternate display mode by typing <code>A</code>.  Once in this mode, you can use the <code>a</code> and <code>w</code> keys to move between the four windows (you will see the window update in the top left corner of the page), and type <code>G</code> to rename the current window to whatever you want.  The advantage here is the ability to see four windows that are all configured slightly different at the same time.</p>
<p>So we know how to use the top command, but what does it help us with?  Generally, you would use this program to check just a few things: </p>
<ol>
<li>The summary page - for high level statistics about your computer</li>
<li>%CPU - check to make sure a single process is not eating all of your CPU resources</li>
<li>%MEM - check to make sure that a single process is not eating all of your memory resources.  Remember, the %MEM represents <code>RES</code>, which is “resident memory”, or in other words, “real memory”.  VIRT = RES + SWAP, so if a task’s VIRT is much higher than RES, this means that it is using SWAP, which means that the computer is running  out of space for the process.</li>
</ol>
<p>The top command is great for getting a high level overview of things in regards to process/system utilization, but we have a few more commands that will give greater insight into how our computer is functioning.</p>
<h3 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h3><p>The lsof command is used for listing out open files on the system.  At first glance it does not sound all that interesting, but since UNIX based operating systems store everything as a file, this tool can allow us to see more than just open text files.  There are many ways to utilize this tool, but here are a couple that any bash user might find useful at some point.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># List all the files that the user zach has open</span></span><br><span class="line">lsof -u zach</span><br><span class="line"></span><br><span class="line"><span class="comment"># List all network connections</span></span><br><span class="line">lsof -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># List all processes running on port 22</span></span><br><span class="line">lsof -i TCP:22</span><br><span class="line"></span><br><span class="line"><span class="comment"># List all the files that my external hard drive has open </span></span><br><span class="line"><span class="comment"># The +f -- means that we are treating the following as a mount point</span></span><br><span class="line">lsof +f -- /media/my_hard_drive</span><br></pre></td></tr></table></figure>
<h3 id="free-time"><a href="#free-time" class="headerlink" title="free, time"></a>free, time</h3><p>The free command is a concise way of showing your system resources at a given moment.  I suggest appending the <code>--mega</code> flag to display the amount of memory in megabytes rather than the default kibibytes.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free --mega</span><br></pre></td></tr></table></figure>
<p>There is also a command called <code>time</code> that will tell you how much CPU time a particular command takes.  For example, I could run the following command: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">time google-chrome</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="comment"># real	0m0.458s</span></span><br><span class="line"><span class="comment"># user	0m0.229s</span></span><br><span class="line"><span class="comment"># sys	0m0.063s</span></span><br></pre></td></tr></table></figure>
<p>This will run the <code>google-chrome</code> executable (opens a Google Chrome window) and track how much real, user, and system time was used for that executable.  Real time is the total elapsed time that it took to run the program.  User time is the time it took the code to run, and System time is the time which the kernel was using system resources.  The following formula will determine how long the system was waiting for resources.</p>
<p>Wait Time = Real - User - System</p>
<p>It is difficult to know what a reasonable wait time is without benchmarking, but this would be the tool to use for such an analysis.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>You may have never thought this would happen, but the post is finally over.  By now, you should have an intermediate to advanced skill-set using the bash shell, and paired with <a href="/blog/2019/user-permissions/">users, groups, and permissions</a>, you will have a high level understanding of Bash (and even Linux for that matter).</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>


    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="http://zachgoll.github.io">Home</a></li>
         
          <li><a href="/blog/archives/">Writing</a></li>
         
          <li><a href="http://zachgoll.github.io/portfolio">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Environment-variables"><span class="toc-number">1.</span> <span class="toc-text">Environment variables</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Shell-Variables"><span class="toc-number">1.1.</span> <span class="toc-text">Shell Variables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PATH-variable"><span class="toc-number">1.2.</span> <span class="toc-text">PATH variable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Common-Commands"><span class="toc-number">1.3.</span> <span class="toc-text">Common Commands</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#grep"><span class="toc-number">1.3.1.</span> <span class="toc-text">grep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#awk-and-sed"><span class="toc-number">1.3.2.</span> <span class="toc-text">awk and sed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Less"><span class="toc-number">1.3.3.</span> <span class="toc-text">Less</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find-and-exec"><span class="toc-number">1.3.4.</span> <span class="toc-text">find and exec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tar-gzip-gunzip"><span class="toc-number">1.3.5.</span> <span class="toc-text">tar, gzip, gunzip</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Advanced-Bash"><span class="toc-number">2.</span> <span class="toc-text">Advanced Bash</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Regular-Expressions"><span class="toc-number">2.1.</span> <span class="toc-text">Regular Expressions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Detailed-Example-Regular-Expression"><span class="toc-number">2.1.1.</span> <span class="toc-text">Detailed Example Regular Expression</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bash-Scripting"><span class="toc-number">2.2.</span> <span class="toc-text">Bash Scripting</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Variable-declarations"><span class="toc-number">2.2.1.</span> <span class="toc-text">Variable declarations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Built-In-Variables"><span class="toc-number">2.2.2.</span> <span class="toc-text">Built-In Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Command-Line-Arguments"><span class="toc-number">2.2.3.</span> <span class="toc-text">Command Line Arguments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reading-user-input"><span class="toc-number">2.2.4.</span> <span class="toc-text">Reading user input</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-loops"><span class="toc-number">2.2.5.</span> <span class="toc-text">for loops</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-then-statements"><span class="toc-number">2.2.6.</span> <span class="toc-text">if-then statements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Functions"><span class="toc-number">2.2.7.</span> <span class="toc-text">Functions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Virtual-Machines-and-SSH-Protocol"><span class="toc-number">2.3.</span> <span class="toc-text">Virtual Machines and SSH Protocol</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Permanently-Add-Keys-to-ssh-agent"><span class="toc-number">2.3.1.</span> <span class="toc-text">Permanently Add Keys to ssh-agent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#From-local-computer-to-remote-machine"><span class="toc-number">2.3.2.</span> <span class="toc-text">From local computer to remote machine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#From-remote-machine-to-local-computer"><span class="toc-number">2.3.3.</span> <span class="toc-text">From remote machine to local computer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Downloading-packages-to-your-remote-machine-with-wget"><span class="toc-number">2.3.4.</span> <span class="toc-text">Downloading packages to your remote machine with wget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-VSCode-with-your-remote-machine"><span class="toc-number">2.3.5.</span> <span class="toc-text">Using VSCode with your remote machine</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Networking-on-Command-Line"><span class="toc-number">2.4.</span> <span class="toc-text">Networking on Command Line</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Your-home-network-and-the-internet"><span class="toc-number">2.4.1.</span> <span class="toc-text">Your home network and the internet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ifconfig"><span class="toc-number">2.4.2.</span> <span class="toc-text">ifconfig</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ping"><span class="toc-number">2.4.3.</span> <span class="toc-text">ping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#traceroute"><span class="toc-number">2.4.4.</span> <span class="toc-text">traceroute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netstat"><span class="toc-number">2.4.5.</span> <span class="toc-text">netstat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dig-host-whois"><span class="toc-number">2.4.6.</span> <span class="toc-text">dig/host/whois</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Process-Management-and-System-Management"><span class="toc-number">2.5.</span> <span class="toc-text">Process Management and System Management</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What-is-a-Process"><span class="toc-number">2.5.1.</span> <span class="toc-text">What is a Process?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Processes-Behind-the-Scenes"><span class="toc-number">2.5.2.</span> <span class="toc-text">Processes Behind the Scenes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Foreground-vs-Background-Processes"><span class="toc-number">2.5.3.</span> <span class="toc-text">Foreground vs. Background Processes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ps-and-top-commands-system-performance-management"><span class="toc-number">2.5.4.</span> <span class="toc-text">ps and top commands (system performance management)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lsof"><span class="toc-number">2.5.5.</span> <span class="toc-text">lsof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free-time"><span class="toc-number">2.5.6.</span> <span class="toc-text">free, time</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">2.6.</span> <span class="toc-text">Conclusion</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://zachgoll.github.io/blog/2019/bash-essentials/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://zachgoll.github.io/blog/2019/bash-essentials/&text=Bash Essentials"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://zachgoll.github.io/blog/2019/bash-essentials/&title=Bash Essentials"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://zachgoll.github.io/blog/2019/bash-essentials/&is_video=false&description=Bash Essentials"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Bash Essentials&body=Check out this article: http://zachgoll.github.io/blog/2019/bash-essentials/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://zachgoll.github.io/blog/2019/bash-essentials/&title=Bash Essentials"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://zachgoll.github.io/blog/2019/bash-essentials/&title=Bash Essentials"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://zachgoll.github.io/blog/2019/bash-essentials/&title=Bash Essentials"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://zachgoll.github.io/blog/2019/bash-essentials/&title=Bash Essentials"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://zachgoll.github.io/blog/2019/bash-essentials/&name=Bash Essentials&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 Zach Gollwitzer
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="http://zachgoll.github.io">Home</a></li>
         
          <li><a href="/blog/archives/">Writing</a></li>
         
          <li><a href="http://zachgoll.github.io/portfolio">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/blog/lib/font-awesome/css/fontawesome-all.min.css">
<link rel="stylesheet" href="/blog/lib/justified-gallery/css/justifiedGallery.min.css">

<!-- jquery -->
<script src="/blog/lib/jquery/jquery.min.js"></script>
<script src="/blog/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/blog/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-149577498-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'zachgoll';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


